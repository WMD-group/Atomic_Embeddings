{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AtomicEmbeddings This site contains the project documentation for the AtomicEmbeddings package which provides tools and examples of analysing and visualising elemental representation data. Table of Contents The documentation consists of the following six parts: About Getting Started Python API Tutorials Reference Contributing Project Overview Analyse elemental representation data. Modules exported by this package: AtomicEmbeddings.core : Provides the Embedding class. AtomicEmbeddings.composition : Tools to featurise compositions.","title":"Home"},{"location":"#welcome-to-atomicembeddings","text":"This site contains the project documentation for the AtomicEmbeddings package which provides tools and examples of analysing and visualising elemental representation data.","title":"Welcome to AtomicEmbeddings"},{"location":"#table-of-contents","text":"The documentation consists of the following six parts: About Getting Started Python API Tutorials Reference Contributing","title":"Table of Contents"},{"location":"#project-overview","text":"Analyse elemental representation data. Modules exported by this package: AtomicEmbeddings.core : Provides the Embedding class. AtomicEmbeddings.composition : Tools to featurise compositions.","title":"Project Overview"},{"location":"about/","text":"About the AtomicEmbeddings package ==== The Atomic Embeddings package provides high-level tools for analysing elemental embeddings data. This primarily involves visualising the correlation between embedding schemes using different statistical measures. Motivation Machine learning approaches for materials informatics have become increasingly widespread. Some of these involve the use of deep learning techniques where the representation of the elements is learned rather than specified by the user of the model. While an important goal of machine learning training is to minimise the chosen error function to make more accurate predictions, it is also important for us material scientists to be able to interpret these models. As such, we aim to evaluate and compare different atomic embedding schemes in a consistent framework.","title":"About"},{"location":"about/#about-the-atomicembeddings-package","text":"==== The Atomic Embeddings package provides high-level tools for analysing elemental embeddings data. This primarily involves visualising the correlation between embedding schemes using different statistical measures.","title":"About the AtomicEmbeddings package"},{"location":"about/#motivation","text":"Machine learning approaches for materials informatics have become increasingly widespread. Some of these involve the use of deep learning techniques where the representation of the elements is learned rather than specified by the user of the model. While an important goal of machine learning training is to minimise the chosen error function to make more accurate predictions, it is also important for us material scientists to be able to interpret these models. As such, we aim to evaluate and compare different atomic embedding schemes in a consistent framework.","title":"Motivation"},{"location":"contribution/","text":"Bug reports, feature requests and questions Please use the Issue Tracker to report bugs or request features in the first instance. Contributions are always welcome. Code contributions We are always looking for ways to make AtomicEmbeddings better and a more useful to a wider community. For making contributions, use the \"Fork and Pull\" workflow to make contributions and stick as closely as possible to the following: Code style should comply with PEP8 where possible. Google's house style is also helpful, including a good model for docstrings. Please use comments liberally when adding nontrivial features, and take the chance to clean up other people's code while looking at it. Add tests wherever possible, and use the test suite to check if you broke anything.","title":"Contributing"},{"location":"contribution/#bug-reports-feature-requests-and-questions","text":"Please use the Issue Tracker to report bugs or request features in the first instance. Contributions are always welcome.","title":"Bug reports, feature requests and questions"},{"location":"contribution/#code-contributions","text":"We are always looking for ways to make AtomicEmbeddings better and a more useful to a wider community. For making contributions, use the \"Fork and Pull\" workflow to make contributions and stick as closely as possible to the following: Code style should comply with PEP8 where possible. Google's house style is also helpful, including a good model for docstrings. Please use comments liberally when adding nontrivial features, and take the chance to clean up other people's code while looking at it. Add tests wherever possible, and use the test suite to check if you broke anything.","title":"Code contributions"},{"location":"installation/","text":"The latest version of the package can be installed using: pip install git+git://github.com/WMD-group/Atomic_Embeddings.git Developer's installation (optional) For development work, AtomicEmbeddings can eb installed from a copy of the source repository ; this is preferred if using experimental code branches. To clone the project from Github and make a local installation: git clone https://github.com/WMD-group/Atomic_Embeddings.git cd Atomic_Embeddings pip install --user -e . With -e , pip will create links to the source folder so that the changes to the code will be reflected on the PATH.","title":"Getting Started"},{"location":"installation/#developers-installation-optional","text":"For development work, AtomicEmbeddings can eb installed from a copy of the source repository ; this is preferred if using experimental code branches. To clone the project from Github and make a local installation: git clone https://github.com/WMD-group/Atomic_Embeddings.git cd Atomic_Embeddings pip install --user -e . With -e , pip will create links to the source folder so that the changes to the code will be reflected on the PATH.","title":"Developer's installation (optional)"},{"location":"reference/","text":"Elemental Embeddings The data contained in this folder is a collection of various elemental representation/embedding schemes Magpie The following paper describes the details of the Materials Agnostic Platform for Informatics and Exploration (Magpie) framework: A general-purpose machine learning framework for predicting properties of inorganic materials The source code for Magpie can be found here The 22 dimensional embedding vector includes the following elemental properties: Click to see the 22 properties * Number; * Mendeleev number; * Atomic weight; * Melting temperature; * Group number; * Period; * Covalent Radius; * Electronegativity; * no. of s, p, d, f valence electrons (4 features); * no. of valence electrons; * no. of unfilled: s, p, d, f orbitals (4 features), * no. of unfilled orbtials * GSvolume_pa (DFT volume per atom of T=0K ground state from the OQMD) * GSbandgap(DFT bandgap energy of T=0K ground state from the OQMD) * GSmagmom (DFT magnetic moment of T=0K ground state from the OQMD) * Space Group Number magpie_sc is scaled version of the magpie embeddings mat2vec The following paper describes the implementation of mat2vec: Unsupervised word embeddings capture latent knowledge from materials science literature MatScholar The following paper describes the natural language processing implementation of Materials Scholar (matscholar): Named Entity Recognition and Normalization Applied to Large-Scale Information Extraction from the Materials Science Literature MEGnet The following paper describes the details of the construction of the MatErials Graph Network (MEGNet): Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals Modified Pettifor scale The following paper describes the details of the modified Pettifor chemical scale: The optimal one dimensional periodic table: a modified Pettifor chemical scale from data mining Oliynkyk The following paper describes the details: High-Throughput Machine-Learning-Driven Synthesis of Full-Heusler Compounds The 44 features of the embedding vector are formed of the following properties: Click to see the 44 features! * Number * Atomic_Weight * Period * Group * Families * Metal * Nonmetal * Metalliod * Mendeleev_Number * l_quantum_number * Atomic_Radius * Miracle_Radius_[pm] * Covalent_Radius * Zunger_radii_sum * Ionic_radius * crystal_radius * Pauling_Electronegativity * MB_electonegativity * Gordy_electonegativity * Mulliken_EN * Allred-Rockow_electronegativity * Metallic_valence * Number_of_valence_electrons * Gilmor_number_of_valence_electron * valence_s * valence_p * valence_d * valence_f * Number_of_unfilled_s_valence_electrons * Number_of_unfilled_p_valence_electrons * Number_of_unfilled_d_valence_electrons * Number_of_unfilled_f_valence_electrons * Outer_shell_electrons * 1st_ionization_potential_(kJ/mol) * Polarizability(A^3) * Melting_point_(K) * Boiling_Point_(K) * Density_(g/mL) * Specific_heat_(J/g_K)_ * Heat_of_fusion_(kJ/mol)_ * Heat_of_vaporization_(kJ/mol)_ * Thermal_conductivity_(W/(m_K))_ * Heat_atomization(kJ/mol) * Cohesive_energy oliynyk_sc is scaled version of the oliynyk embeddings Random This is a set of 200-dimensional vectors in which the components are randomly generated The 118 200-dimensional vectors in random_200_new was generated using the following code: import numpy as np mu , sigma = 0 , 0.1 # mean and standard deviation s = np.random.normal(mu, sigma, 1000) s = np . random . default_rng ( seed = 42 ) . normal ( mu , sigma , ( 118 , 200 )) SkipAtom The following paper describes the details: Distributed representations of atoms and materials for machine learning","title":"Elemental Embeddings"},{"location":"reference/#elemental-embeddings","text":"The data contained in this folder is a collection of various elemental representation/embedding schemes","title":"Elemental Embeddings"},{"location":"reference/#magpie","text":"The following paper describes the details of the Materials Agnostic Platform for Informatics and Exploration (Magpie) framework: A general-purpose machine learning framework for predicting properties of inorganic materials The source code for Magpie can be found here The 22 dimensional embedding vector includes the following elemental properties: Click to see the 22 properties * Number; * Mendeleev number; * Atomic weight; * Melting temperature; * Group number; * Period; * Covalent Radius; * Electronegativity; * no. of s, p, d, f valence electrons (4 features); * no. of valence electrons; * no. of unfilled: s, p, d, f orbitals (4 features), * no. of unfilled orbtials * GSvolume_pa (DFT volume per atom of T=0K ground state from the OQMD) * GSbandgap(DFT bandgap energy of T=0K ground state from the OQMD) * GSmagmom (DFT magnetic moment of T=0K ground state from the OQMD) * Space Group Number magpie_sc is scaled version of the magpie embeddings","title":"Magpie"},{"location":"reference/#mat2vec","text":"The following paper describes the implementation of mat2vec: Unsupervised word embeddings capture latent knowledge from materials science literature","title":"mat2vec"},{"location":"reference/#matscholar","text":"The following paper describes the natural language processing implementation of Materials Scholar (matscholar): Named Entity Recognition and Normalization Applied to Large-Scale Information Extraction from the Materials Science Literature","title":"MatScholar"},{"location":"reference/#megnet","text":"The following paper describes the details of the construction of the MatErials Graph Network (MEGNet): Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals","title":"MEGnet"},{"location":"reference/#modified-pettifor-scale","text":"The following paper describes the details of the modified Pettifor chemical scale: The optimal one dimensional periodic table: a modified Pettifor chemical scale from data mining","title":"Modified Pettifor scale"},{"location":"reference/#oliynkyk","text":"The following paper describes the details: High-Throughput Machine-Learning-Driven Synthesis of Full-Heusler Compounds The 44 features of the embedding vector are formed of the following properties: Click to see the 44 features! * Number * Atomic_Weight * Period * Group * Families * Metal * Nonmetal * Metalliod * Mendeleev_Number * l_quantum_number * Atomic_Radius * Miracle_Radius_[pm] * Covalent_Radius * Zunger_radii_sum * Ionic_radius * crystal_radius * Pauling_Electronegativity * MB_electonegativity * Gordy_electonegativity * Mulliken_EN * Allred-Rockow_electronegativity * Metallic_valence * Number_of_valence_electrons * Gilmor_number_of_valence_electron * valence_s * valence_p * valence_d * valence_f * Number_of_unfilled_s_valence_electrons * Number_of_unfilled_p_valence_electrons * Number_of_unfilled_d_valence_electrons * Number_of_unfilled_f_valence_electrons * Outer_shell_electrons * 1st_ionization_potential_(kJ/mol) * Polarizability(A^3) * Melting_point_(K) * Boiling_Point_(K) * Density_(g/mL) * Specific_heat_(J/g_K)_ * Heat_of_fusion_(kJ/mol)_ * Heat_of_vaporization_(kJ/mol)_ * Thermal_conductivity_(W/(m_K))_ * Heat_atomization(kJ/mol) * Cohesive_energy oliynyk_sc is scaled version of the oliynyk embeddings","title":"Oliynkyk"},{"location":"reference/#random","text":"This is a set of 200-dimensional vectors in which the components are randomly generated The 118 200-dimensional vectors in random_200_new was generated using the following code: import numpy as np mu , sigma = 0 , 0.1 # mean and standard deviation s = np.random.normal(mu, sigma, 1000) s = np . random . default_rng ( seed = 42 ) . normal ( mu , sigma , ( 118 , 200 ))","title":"Random"},{"location":"reference/#skipatom","text":"The following paper describes the details: Distributed representations of atoms and materials for machine learning","title":"SkipAtom"},{"location":"tutorials/","text":"Here we will demonstrate how to use some of AtomicEmbeddings 's features. For full worked examples of using the package, please refer to the Jupyter notebooks in the examples section of the Github repo . Atomic_Embeddings The Embedding class lies at the heart of the package. It handles elemental representation data and enables analysis and visualisation. from AtomicEmbeddings.core import Embedding # Load the magpie data magpie = Embedding . load_data ( 'magpie' ) # Print out some of the properties of the Atomic_Embeddings class # Print the dimensions of the embedding print ( f 'The magpie representation has embeddings of dimension { magpie . dim } \\n ' ) print ( magpie . element_list ) # prints out all the elements considered for this representation The magpie representation has embeddings of dimension 21 [ 'H' , 'He' , 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' ]","title":"Tutorial"},{"location":"tutorials/#atomic_embeddings","text":"The Embedding class lies at the heart of the package. It handles elemental representation data and enables analysis and visualisation. from AtomicEmbeddings.core import Embedding # Load the magpie data magpie = Embedding . load_data ( 'magpie' ) # Print out some of the properties of the Atomic_Embeddings class # Print the dimensions of the embedding print ( f 'The magpie representation has embeddings of dimension { magpie . dim } \\n ' ) print ( magpie . element_list ) # prints out all the elements considered for this representation The magpie representation has embeddings of dimension 21 [ 'H' , 'He' , 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' ]","title":"Atomic_Embeddings"},{"location":"python_api/composition/","text":"This module provides a class for handling compositional embeddings. Typical usage example Fe2O3_magpie = CompositionalEmbedding(\"Fe2O3\", \"magpie\") CompositionalEmbedding Class to handle compositional embeddings. Parameters: Name Type Description Default formula str A string formula e.g. CsPbI3, Li7La3Zr2O12 required embedding Union [ str , Embedding ] Either a string name of the embedding required x int The non-stoichiometric amount. 1 Source code in AtomicEmbeddings/composition.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 class CompositionalEmbedding : \"\"\" Class to handle compositional embeddings. Args: formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12 embedding (Union[str, Embedding]): Either a string name of the embedding or an Embedding instance x (int, optional): The non-stoichiometric amount. \"\"\" def __init__ ( self , formula : str , embedding : Union [ str , Embedding ], x = 1 ): \"\"\"Initialise a CompositionalEmbedding instance.\"\"\" self . embedding = embedding # If a string has been passed for embedding, create an Embedding instance if isinstance ( embedding , str ): self . embedding = Embedding . load_data ( embedding ) self . embedding_name : str = self . embedding . embedding_name # Set an attribute for the formula self . formula = formula # Set an attribute for the comp dict comp_dict = formula_parser ( self . formula ) self . _natoms = 0 for el , v in comp_dict . items (): if v < 0 : raise ValueError ( \"Formula cannot contain negative amounts of elements\" ) self . _natoms += abs ( v ) self . composition = comp_dict # Set an attribute for the element list self . element_list = list ( self . composition . keys ()) # Set an attribute for the element matrix self . el_matrix = np . zeros ( shape = ( len ( self . composition ), len ( self . embedding . embeddings [ \"H\" ])) ) for i , k in enumerate ( self . composition . keys ()): self . el_matrix [ i ] = self . embedding . embeddings [ k ] self . el_matrix = np . nan_to_num ( self . el_matrix ) # Set an attribute for the stoichiometric vector self . stoich_vector = np . array ( list ( self . composition . values ())) # Set an attribute for the normalised stoichiometric vector self . norm_stoich_vector = self . stoich_vector / self . _natoms @property def fractional_composition ( self ): \"\"\"Fractional composition of the Composition.\"\"\" return _get_fractional_composition ( self . formula ) @property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in Composition.\"\"\" return self . _natoms @property def embedding_dim ( self ) -> int : \"\"\"Dimension of the embedding.\"\"\" return self . embedding . dim def as_dict ( self ) -> dict : # TO-DO: Need to create a dict representation for the embedding class \"\"\"Return the CompositionalEmbedding class as a dict.\"\"\" return { \"formula\" : self . formula , \"composition\" : self . composition , \"fractional_composition\" : self . fractional_composition , # 'embedding':self.embedding.as_ } # Se # Set an attribute pass def _mean_feature_vector ( self ) -> np . ndarray : \"\"\" Compute a weighted mean feature vector based of the embedding. The dimension of the feature vector is the same as the embedding. \"\"\" return np . dot ( self . norm_stoich_vector , self . el_matrix ) def _variance_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a weighted variance feature vector.\"\"\" diff_matrix = self . el_matrix - self . _mean_feature_vector () diff_matrix = diff_matrix ** 2 return np . dot ( self . norm_stoich_vector , diff_matrix ) def _minpool_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a min pooled feature vector.\"\"\" return np . min ( self . el_matrix , axis = 0 ) def _maxpool_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a max pooled feature vector.\"\"\" return np . max ( self . el_matrix , axis = 0 ) def _range_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a range feature vector.\"\"\" return np . ptp ( self . el_matrix , axis = 0 ) def _sum_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the weighted sum feature vector.\"\"\" return np . dot ( self . stoich_vector , self . el_matrix ) def _geometric_mean_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the geometric mean feature vector.\"\"\" return np . exp ( np . dot ( self . norm_stoich_vector , np . log ( self . el_matrix ))) def _harmonic_mean_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the harmonic mean feature vector.\"\"\" return np . reciprocal ( np . dot ( self . norm_stoich_vector , np . reciprocal ( self . el_matrix )) ) _stats_functions_dict = { \"mean\" : \"_mean_feature_vector\" , \"variance\" : \"_variance_feature_vector\" , \"minpool\" : \"_minpool_feature_vector\" , \"maxpool\" : \"_maxpool_feature_vector\" , \"range\" : \"_range_feature_vector\" , \"sum\" : \"_sum_feature_vector\" , \"geometric_mean\" : \"_geometric_mean_feature_vector\" , \"harmonic_mean\" : \"_harmonic_mean_feature_vector\" , } def feature_vector ( self , stats : Union [ str , list ] = [ \"mean\" ]): \"\"\" Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Args: stats (list): A list of strings specifying the statistics to be computed. The default is ['mean']. Returns: np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). \"\"\" implemented_stats = [ \"mean\" , \"variance\" , \"minpool\" , \"maxpool\" , \"range\" , \"sum\" , \"geometric_mean\" , \"harmonic_mean\" , ] if isinstance ( stats , str ): stats = [ stats ] if not isinstance ( stats , list ): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ isinstance ( s , str ) for s in stats ]): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ s in implemented_stats for s in stats ]): raise ValueError ( f \" { [ stat for stat in stats if stat not in implemented_stats ] } \" \"are not valid statistics.\" ) feature_vector = [] for s in stats : feature_vector . append ( getattr ( self , self . _stats_functions_dict [ s ])()) return np . concatenate ( feature_vector ) def __repr__ ( self ): return ( f \"CompositionalEmbedding(formula= { self . formula } , \" f \"embedding= { self . embedding } )\" ) def __str__ ( self ): return ( f \"CompositionalEmbedding(formula= { self . formula } , \" f \"embedding= { self . embedding } )\" ) def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return self . formula == other . formula and self . embedding == other . embedding else : return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __hash__ ( self ): return hash (( self . formula , self . embedding )) __init__ ( formula , embedding , x = 1 ) Initialise a CompositionalEmbedding instance. Source code in AtomicEmbeddings/composition.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , formula : str , embedding : Union [ str , Embedding ], x = 1 ): \"\"\"Initialise a CompositionalEmbedding instance.\"\"\" self . embedding = embedding # If a string has been passed for embedding, create an Embedding instance if isinstance ( embedding , str ): self . embedding = Embedding . load_data ( embedding ) self . embedding_name : str = self . embedding . embedding_name # Set an attribute for the formula self . formula = formula # Set an attribute for the comp dict comp_dict = formula_parser ( self . formula ) self . _natoms = 0 for el , v in comp_dict . items (): if v < 0 : raise ValueError ( \"Formula cannot contain negative amounts of elements\" ) self . _natoms += abs ( v ) self . composition = comp_dict # Set an attribute for the element list self . element_list = list ( self . composition . keys ()) # Set an attribute for the element matrix self . el_matrix = np . zeros ( shape = ( len ( self . composition ), len ( self . embedding . embeddings [ \"H\" ])) ) for i , k in enumerate ( self . composition . keys ()): self . el_matrix [ i ] = self . embedding . embeddings [ k ] self . el_matrix = np . nan_to_num ( self . el_matrix ) # Set an attribute for the stoichiometric vector self . stoich_vector = np . array ( list ( self . composition . values ())) # Set an attribute for the normalised stoichiometric vector self . norm_stoich_vector = self . stoich_vector / self . _natoms as_dict () Return the CompositionalEmbedding class as a dict. Source code in AtomicEmbeddings/composition.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def as_dict ( self ) -> dict : # TO-DO: Need to create a dict representation for the embedding class \"\"\"Return the CompositionalEmbedding class as a dict.\"\"\" return { \"formula\" : self . formula , \"composition\" : self . composition , \"fractional_composition\" : self . fractional_composition , # 'embedding':self.embedding.as_ } # Se # Set an attribute pass embedding_dim () property Dimension of the embedding. Source code in AtomicEmbeddings/composition.py 143 144 145 146 @property def embedding_dim ( self ) -> int : \"\"\"Dimension of the embedding.\"\"\" return self . embedding . dim feature_vector ( stats = [ 'mean' ]) Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Parameters: Name Type Description Default stats list A list of strings specifying the statistics to be computed. ['mean'] Returns: Type Description np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). Source code in AtomicEmbeddings/composition.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def feature_vector ( self , stats : Union [ str , list ] = [ \"mean\" ]): \"\"\" Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Args: stats (list): A list of strings specifying the statistics to be computed. The default is ['mean']. Returns: np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). \"\"\" implemented_stats = [ \"mean\" , \"variance\" , \"minpool\" , \"maxpool\" , \"range\" , \"sum\" , \"geometric_mean\" , \"harmonic_mean\" , ] if isinstance ( stats , str ): stats = [ stats ] if not isinstance ( stats , list ): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ isinstance ( s , str ) for s in stats ]): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ s in implemented_stats for s in stats ]): raise ValueError ( f \" { [ stat for stat in stats if stat not in implemented_stats ] } \" \"are not valid statistics.\" ) feature_vector = [] for s in stats : feature_vector . append ( getattr ( self , self . _stats_functions_dict [ s ])()) return np . concatenate ( feature_vector ) fractional_composition () property Fractional composition of the Composition. Source code in AtomicEmbeddings/composition.py 133 134 135 136 @property def fractional_composition ( self ): \"\"\"Fractional composition of the Composition.\"\"\" return _get_fractional_composition ( self . formula ) num_atoms () property Total number of atoms in Composition. Source code in AtomicEmbeddings/composition.py 138 139 140 141 @property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in Composition.\"\"\" return self . _natoms composition_featuriser ( data , embedding = 'magpie' , stats = [ 'mean' ], inplace = False ) Compute a feature vector for a composition. The feature vector is based on the statistics specified in the stats argument. Parameters: Name Type Description Default data Union [ pd . DataFrame , pd . Series , list , CompositionalEmbedding ] required embedding Union [ Embedding , str ] A Embedding class or a string 'magpie' stats Union [ str , list ] A list of statistics to be computed. ['mean'] inplace bool Whether to perform the operation in place on the data. False Returns: Type Description pd . DataFrame Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector, pd . DataFrame or a list of feature vectors is returned Source code in AtomicEmbeddings/composition.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def composition_featuriser ( data : Union [ pd . DataFrame , pd . Series , CompositionalEmbedding , list ], embedding : Union [ Embedding , str ] = \"magpie\" , stats : Union [ str , list ] = [ \"mean\" ], inplace : bool = False , ) -> pd . DataFrame : \"\"\" Compute a feature vector for a composition. The feature vector is based on the statistics specified in the stats argument. Args: data (Union[pd.DataFrame, pd.Series, list, CompositionalEmbedding]): A pandas DataFrame or Series containing a column named 'formula', a list of formula, or a CompositionalEmbedding class embedding (Union[Embedding, str], optional): A Embedding class or a string stats (Union[str, list], optional): A list of statistics to be computed. The default is ['mean']. inplace (bool, optional): Whether to perform the operation in place on the data. The default is False. Returns: Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector, or a list of feature vectors is returned \"\"\" if isinstance ( data , pd . DataFrame ): if not inplace : data = data . copy () if \"formula\" not in data . columns : raise ValueError ( \"The data must contain a column named 'formula' to featurise.\" ) data [ \"composition\" ] = data [ \"formula\" ] . progress_apply ( lambda x : CompositionalEmbedding ( x , embedding ) ) data [ \"feature_vector\" ] = data [ \"composition\" ] . progress_apply ( lambda x : x . feature_vector ( stats ) ) data . drop ( \"composition\" , axis = 1 , inplace = True ) return data elif isinstance ( data , pd . Series ): if not inplace : data = data . copy () data [ \"composition\" ] = data [ \"formula\" ] . progress_apply ( lambda x : CompositionalEmbedding ( x , embedding ) ) data [ \"feature_vector\" ] = data [ \"composition\" ] . progress_apply ( lambda x : x . feature_vector ( stats ) ) data . drop ( \"composition\" , axis = 1 , inplace = True ) return data elif isinstance ( data , list ): comps = [ CompositionalEmbedding ( x , embedding ) for x in data ] return [ x . feature_vector ( stats ) for x in tqdm ( comps )] elif isinstance ( data , CompositionalEmbedding ): return data . feature_vector ( stats ) else : raise ValueError ( \"The data must be a pandas DataFrame, Series, \" \"list or CompositionalEmbedding class.\" ) formula_parser ( formula ) Parse a string formula. Returns a dictionary of the composition with key:value pairs of element symbol:amount. Parameters: Name Type Description Default formula str A string formula e.g. CsPbI3, Li7La3Zr2O12 required Returns: Type Description dict A dictionary of the composition Source code in AtomicEmbeddings/composition.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def formula_parser ( formula : str ) -> Dict [ str , float ]: # TO-DO: Add validation to check composition contains real elements. \"\"\" Parse a string formula. Returns a dictionary of the composition with key:value pairs of element symbol:amount. Args: formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12 Returns: (dict): A dictionary of the composition \"\"\" # For Metallofullerene formula = formula . replace ( \"@\" , \"\" ) regex = r \"\\(([^\\(\\)]+)\\)\\s*([\\.e\\d]*)\" r = re . compile ( regex ) m = re . search ( r , formula ) if m : factor = 1.0 if m . group ( 2 ) != \"\" : factor = float ( m . group ( 2 )) unit_sym_dict = _get_sym_dict ( m . group ( 1 ), factor ) expanded_sym = \"\" . join ([ f \" { el }{ amt } \" for el , amt in unit_sym_dict . items ()]) expanded_formula = formula . replace ( m . group (), expanded_sym ) return formula_parser ( expanded_formula ) return _get_sym_dict ( formula , 1 )","title":"Composition module"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding","text":"Class to handle compositional embeddings. Parameters: Name Type Description Default formula str A string formula e.g. CsPbI3, Li7La3Zr2O12 required embedding Union [ str , Embedding ] Either a string name of the embedding required x int The non-stoichiometric amount. 1 Source code in AtomicEmbeddings/composition.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 class CompositionalEmbedding : \"\"\" Class to handle compositional embeddings. Args: formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12 embedding (Union[str, Embedding]): Either a string name of the embedding or an Embedding instance x (int, optional): The non-stoichiometric amount. \"\"\" def __init__ ( self , formula : str , embedding : Union [ str , Embedding ], x = 1 ): \"\"\"Initialise a CompositionalEmbedding instance.\"\"\" self . embedding = embedding # If a string has been passed for embedding, create an Embedding instance if isinstance ( embedding , str ): self . embedding = Embedding . load_data ( embedding ) self . embedding_name : str = self . embedding . embedding_name # Set an attribute for the formula self . formula = formula # Set an attribute for the comp dict comp_dict = formula_parser ( self . formula ) self . _natoms = 0 for el , v in comp_dict . items (): if v < 0 : raise ValueError ( \"Formula cannot contain negative amounts of elements\" ) self . _natoms += abs ( v ) self . composition = comp_dict # Set an attribute for the element list self . element_list = list ( self . composition . keys ()) # Set an attribute for the element matrix self . el_matrix = np . zeros ( shape = ( len ( self . composition ), len ( self . embedding . embeddings [ \"H\" ])) ) for i , k in enumerate ( self . composition . keys ()): self . el_matrix [ i ] = self . embedding . embeddings [ k ] self . el_matrix = np . nan_to_num ( self . el_matrix ) # Set an attribute for the stoichiometric vector self . stoich_vector = np . array ( list ( self . composition . values ())) # Set an attribute for the normalised stoichiometric vector self . norm_stoich_vector = self . stoich_vector / self . _natoms @property def fractional_composition ( self ): \"\"\"Fractional composition of the Composition.\"\"\" return _get_fractional_composition ( self . formula ) @property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in Composition.\"\"\" return self . _natoms @property def embedding_dim ( self ) -> int : \"\"\"Dimension of the embedding.\"\"\" return self . embedding . dim def as_dict ( self ) -> dict : # TO-DO: Need to create a dict representation for the embedding class \"\"\"Return the CompositionalEmbedding class as a dict.\"\"\" return { \"formula\" : self . formula , \"composition\" : self . composition , \"fractional_composition\" : self . fractional_composition , # 'embedding':self.embedding.as_ } # Se # Set an attribute pass def _mean_feature_vector ( self ) -> np . ndarray : \"\"\" Compute a weighted mean feature vector based of the embedding. The dimension of the feature vector is the same as the embedding. \"\"\" return np . dot ( self . norm_stoich_vector , self . el_matrix ) def _variance_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a weighted variance feature vector.\"\"\" diff_matrix = self . el_matrix - self . _mean_feature_vector () diff_matrix = diff_matrix ** 2 return np . dot ( self . norm_stoich_vector , diff_matrix ) def _minpool_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a min pooled feature vector.\"\"\" return np . min ( self . el_matrix , axis = 0 ) def _maxpool_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a max pooled feature vector.\"\"\" return np . max ( self . el_matrix , axis = 0 ) def _range_feature_vector ( self ) -> np . ndarray : \"\"\"Compute a range feature vector.\"\"\" return np . ptp ( self . el_matrix , axis = 0 ) def _sum_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the weighted sum feature vector.\"\"\" return np . dot ( self . stoich_vector , self . el_matrix ) def _geometric_mean_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the geometric mean feature vector.\"\"\" return np . exp ( np . dot ( self . norm_stoich_vector , np . log ( self . el_matrix ))) def _harmonic_mean_feature_vector ( self ) -> np . ndarray : \"\"\"Compute the harmonic mean feature vector.\"\"\" return np . reciprocal ( np . dot ( self . norm_stoich_vector , np . reciprocal ( self . el_matrix )) ) _stats_functions_dict = { \"mean\" : \"_mean_feature_vector\" , \"variance\" : \"_variance_feature_vector\" , \"minpool\" : \"_minpool_feature_vector\" , \"maxpool\" : \"_maxpool_feature_vector\" , \"range\" : \"_range_feature_vector\" , \"sum\" : \"_sum_feature_vector\" , \"geometric_mean\" : \"_geometric_mean_feature_vector\" , \"harmonic_mean\" : \"_harmonic_mean_feature_vector\" , } def feature_vector ( self , stats : Union [ str , list ] = [ \"mean\" ]): \"\"\" Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Args: stats (list): A list of strings specifying the statistics to be computed. The default is ['mean']. Returns: np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). \"\"\" implemented_stats = [ \"mean\" , \"variance\" , \"minpool\" , \"maxpool\" , \"range\" , \"sum\" , \"geometric_mean\" , \"harmonic_mean\" , ] if isinstance ( stats , str ): stats = [ stats ] if not isinstance ( stats , list ): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ isinstance ( s , str ) for s in stats ]): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ s in implemented_stats for s in stats ]): raise ValueError ( f \" { [ stat for stat in stats if stat not in implemented_stats ] } \" \"are not valid statistics.\" ) feature_vector = [] for s in stats : feature_vector . append ( getattr ( self , self . _stats_functions_dict [ s ])()) return np . concatenate ( feature_vector ) def __repr__ ( self ): return ( f \"CompositionalEmbedding(formula= { self . formula } , \" f \"embedding= { self . embedding } )\" ) def __str__ ( self ): return ( f \"CompositionalEmbedding(formula= { self . formula } , \" f \"embedding= { self . embedding } )\" ) def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return self . formula == other . formula and self . embedding == other . embedding else : return False def __ne__ ( self , other ): return not self . __eq__ ( other ) def __hash__ ( self ): return hash (( self . formula , self . embedding ))","title":"CompositionalEmbedding"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.__init__","text":"Initialise a CompositionalEmbedding instance. Source code in AtomicEmbeddings/composition.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , formula : str , embedding : Union [ str , Embedding ], x = 1 ): \"\"\"Initialise a CompositionalEmbedding instance.\"\"\" self . embedding = embedding # If a string has been passed for embedding, create an Embedding instance if isinstance ( embedding , str ): self . embedding = Embedding . load_data ( embedding ) self . embedding_name : str = self . embedding . embedding_name # Set an attribute for the formula self . formula = formula # Set an attribute for the comp dict comp_dict = formula_parser ( self . formula ) self . _natoms = 0 for el , v in comp_dict . items (): if v < 0 : raise ValueError ( \"Formula cannot contain negative amounts of elements\" ) self . _natoms += abs ( v ) self . composition = comp_dict # Set an attribute for the element list self . element_list = list ( self . composition . keys ()) # Set an attribute for the element matrix self . el_matrix = np . zeros ( shape = ( len ( self . composition ), len ( self . embedding . embeddings [ \"H\" ])) ) for i , k in enumerate ( self . composition . keys ()): self . el_matrix [ i ] = self . embedding . embeddings [ k ] self . el_matrix = np . nan_to_num ( self . el_matrix ) # Set an attribute for the stoichiometric vector self . stoich_vector = np . array ( list ( self . composition . values ())) # Set an attribute for the normalised stoichiometric vector self . norm_stoich_vector = self . stoich_vector / self . _natoms","title":"__init__()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.as_dict","text":"Return the CompositionalEmbedding class as a dict. Source code in AtomicEmbeddings/composition.py 148 149 150 151 152 153 154 155 156 157 158 159 160 def as_dict ( self ) -> dict : # TO-DO: Need to create a dict representation for the embedding class \"\"\"Return the CompositionalEmbedding class as a dict.\"\"\" return { \"formula\" : self . formula , \"composition\" : self . composition , \"fractional_composition\" : self . fractional_composition , # 'embedding':self.embedding.as_ } # Se # Set an attribute pass","title":"as_dict()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.embedding_dim","text":"Dimension of the embedding. Source code in AtomicEmbeddings/composition.py 143 144 145 146 @property def embedding_dim ( self ) -> int : \"\"\"Dimension of the embedding.\"\"\" return self . embedding . dim","title":"embedding_dim()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.feature_vector","text":"Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Parameters: Name Type Description Default stats list A list of strings specifying the statistics to be computed. ['mean'] Returns: Type Description np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). Source code in AtomicEmbeddings/composition.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def feature_vector ( self , stats : Union [ str , list ] = [ \"mean\" ]): \"\"\" Compute a feature vector. The feature vector is a concatenation of the statistics specified in the stats argument. Args: stats (list): A list of strings specifying the statistics to be computed. The default is ['mean']. Returns: np.ndarray: A feature vector of dimension (len(stats) * embedding_dim). \"\"\" implemented_stats = [ \"mean\" , \"variance\" , \"minpool\" , \"maxpool\" , \"range\" , \"sum\" , \"geometric_mean\" , \"harmonic_mean\" , ] if isinstance ( stats , str ): stats = [ stats ] if not isinstance ( stats , list ): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ isinstance ( s , str ) for s in stats ]): raise ValueError ( \"Stats argument must be a list of strings\" ) if not all ([ s in implemented_stats for s in stats ]): raise ValueError ( f \" { [ stat for stat in stats if stat not in implemented_stats ] } \" \"are not valid statistics.\" ) feature_vector = [] for s in stats : feature_vector . append ( getattr ( self , self . _stats_functions_dict [ s ])()) return np . concatenate ( feature_vector )","title":"feature_vector()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.fractional_composition","text":"Fractional composition of the Composition. Source code in AtomicEmbeddings/composition.py 133 134 135 136 @property def fractional_composition ( self ): \"\"\"Fractional composition of the Composition.\"\"\" return _get_fractional_composition ( self . formula )","title":"fractional_composition()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.num_atoms","text":"Total number of atoms in Composition. Source code in AtomicEmbeddings/composition.py 138 139 140 141 @property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in Composition.\"\"\" return self . _natoms","title":"num_atoms()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.composition_featuriser","text":"Compute a feature vector for a composition. The feature vector is based on the statistics specified in the stats argument. Parameters: Name Type Description Default data Union [ pd . DataFrame , pd . Series , list , CompositionalEmbedding ] required embedding Union [ Embedding , str ] A Embedding class or a string 'magpie' stats Union [ str , list ] A list of statistics to be computed. ['mean'] inplace bool Whether to perform the operation in place on the data. False Returns: Type Description pd . DataFrame Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector, pd . DataFrame or a list of feature vectors is returned Source code in AtomicEmbeddings/composition.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def composition_featuriser ( data : Union [ pd . DataFrame , pd . Series , CompositionalEmbedding , list ], embedding : Union [ Embedding , str ] = \"magpie\" , stats : Union [ str , list ] = [ \"mean\" ], inplace : bool = False , ) -> pd . DataFrame : \"\"\" Compute a feature vector for a composition. The feature vector is based on the statistics specified in the stats argument. Args: data (Union[pd.DataFrame, pd.Series, list, CompositionalEmbedding]): A pandas DataFrame or Series containing a column named 'formula', a list of formula, or a CompositionalEmbedding class embedding (Union[Embedding, str], optional): A Embedding class or a string stats (Union[str, list], optional): A list of statistics to be computed. The default is ['mean']. inplace (bool, optional): Whether to perform the operation in place on the data. The default is False. Returns: Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector, or a list of feature vectors is returned \"\"\" if isinstance ( data , pd . DataFrame ): if not inplace : data = data . copy () if \"formula\" not in data . columns : raise ValueError ( \"The data must contain a column named 'formula' to featurise.\" ) data [ \"composition\" ] = data [ \"formula\" ] . progress_apply ( lambda x : CompositionalEmbedding ( x , embedding ) ) data [ \"feature_vector\" ] = data [ \"composition\" ] . progress_apply ( lambda x : x . feature_vector ( stats ) ) data . drop ( \"composition\" , axis = 1 , inplace = True ) return data elif isinstance ( data , pd . Series ): if not inplace : data = data . copy () data [ \"composition\" ] = data [ \"formula\" ] . progress_apply ( lambda x : CompositionalEmbedding ( x , embedding ) ) data [ \"feature_vector\" ] = data [ \"composition\" ] . progress_apply ( lambda x : x . feature_vector ( stats ) ) data . drop ( \"composition\" , axis = 1 , inplace = True ) return data elif isinstance ( data , list ): comps = [ CompositionalEmbedding ( x , embedding ) for x in data ] return [ x . feature_vector ( stats ) for x in tqdm ( comps )] elif isinstance ( data , CompositionalEmbedding ): return data . feature_vector ( stats ) else : raise ValueError ( \"The data must be a pandas DataFrame, Series, \" \"list or CompositionalEmbedding class.\" )","title":"composition_featuriser()"},{"location":"python_api/composition/#AtomicEmbeddings.composition.formula_parser","text":"Parse a string formula. Returns a dictionary of the composition with key:value pairs of element symbol:amount. Parameters: Name Type Description Default formula str A string formula e.g. CsPbI3, Li7La3Zr2O12 required Returns: Type Description dict A dictionary of the composition Source code in AtomicEmbeddings/composition.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def formula_parser ( formula : str ) -> Dict [ str , float ]: # TO-DO: Add validation to check composition contains real elements. \"\"\" Parse a string formula. Returns a dictionary of the composition with key:value pairs of element symbol:amount. Args: formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12 Returns: (dict): A dictionary of the composition \"\"\" # For Metallofullerene formula = formula . replace ( \"@\" , \"\" ) regex = r \"\\(([^\\(\\)]+)\\)\\s*([\\.e\\d]*)\" r = re . compile ( regex ) m = re . search ( r , formula ) if m : factor = 1.0 if m . group ( 2 ) != \"\" : factor = float ( m . group ( 2 )) unit_sym_dict = _get_sym_dict ( m . group ( 1 ), factor ) expanded_sym = \"\" . join ([ f \" { el }{ amt } \" for el , amt in unit_sym_dict . items ()]) expanded_formula = formula . replace ( m . group (), expanded_sym ) return formula_parser ( expanded_formula ) return _get_sym_dict ( formula , 1 )","title":"formula_parser()"},{"location":"python_api/core/","text":"Provides the Embedding class. This module enables the user load in elemetal representation data and analyse it using statistical functions. Typical usage example megnet16 = Embedding.load_data('megnet16') Embedding Represent an elemental representation. To load an embedding distributed from the package use the load_data() method. Works like a standard python dictionary. The keys are {element: vector} pairs. Adds a few convenience methods related to elemental representations. Source code in AtomicEmbeddings/core.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 class Embedding : \"\"\" Represent an elemental representation. To load an embedding distributed from the package use the load_data() method. Works like a standard python dictionary. The keys are {element: vector} pairs. Adds a few convenience methods related to elemental representations. \"\"\" def __init__ ( self , embeddings : dict , embedding_name : Optional [ str ] = None ): \"\"\"Initialise the Embedding class. Args: embeddings (dict): A {element_symbol: vector} dictionary embedding_name (str): The name of the elemental representation \"\"\" self . embeddings = embeddings self . embedding_name = embedding_name # Grab a random value from the embedding vector _rand_embed = random . choice ( list ( self . embeddings . values ())) # Convert embeddings to numpy array if not already a numpy array if not isinstance ( _rand_embed , np . ndarray ): self . embeddings = { ele : np . array ( self . embeddings [ ele ]) for ele in self . embeddings } # Determines if the embedding vector has a length attribute # (i.e. is not a scalar int or float) # If the 'vector' is a scalar/float, the representation is linear (dim=1) if hasattr ( _rand_embed , \"__len__\" ) and ( not isinstance ( _rand_embed , str )): self . dim : int = len ( random . choice ( list ( self . embeddings . values ()))) else : self . dim : int = int ( 1 ) # Dummy initialisation for results self . _data = [] @staticmethod def load_data ( embedding_name : Optional [ str ] = None ): \"\"\" Create an instance of the `Embedding` class from a default embedding file. The default embeddings are in the table below: | **Name** | **str_name** | |-------------------------|--------------| | Magpie | magpie | | Magpie (scaled) | magpie_sc | | Mat2Vec | mat2vec | | Matscholar | matscholar | | Megnet (16 dimensions) | megnet16 | | Modified pettifor scale | mod_petti | | Oliynyk | oliynyk | | Oliynyk (scaled) | oliynyk_sc | | Random (200 dimensions) | random_200 | | SkipAtom | skipatom | Args: embedding_name (str): The str_name of an embedding file. Returns: Embedding :class:`Embedding` instance. \"\"\" _cbfv_files = { \"magpie\" : \"magpie.csv\" , \"magpie_sc\" : \"magpie_sc.json\" , \"mat2vec\" : \"mat2vec.csv\" , \"matscholar\" : \"matscholar-embedding.json\" , \"megnet16\" : \"megnet16.json\" , \"mod_petti\" : \"mod_petti.json\" , \"oliynyk\" : \"oliynyk.json\" , \"oliynyk_sc\" : \"oliynyk_sc.json\" , \"random_200\" : \"random_200_new.csv\" , \"skipatom\" : \"skipatom_20201009_induced.csv\" , } _cbfv_names = list ( _cbfv_files . keys ()) _cbfv_names_others = [ i for i in _cbfv_names if i not in [ \"skipatom\" , \"random_200\" , \"megnet16\" , \"magpie\" , \"mat2vec\" ] ] # Get the embeddings if embedding_name in _cbfv_files : if embedding_name in [ \"skipatom\" , \"random_200\" , \"magpie\" , \"mat2vec\" ]: _csv = path . join ( data_directory , _cbfv_files [ embedding_name ]) df = pd . read_csv ( _csv ) # Convert df to a dictionary of (ele:embeddings) pairs elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } elif embedding_name == \"megnet16\" : megnet16_json = path . join ( data_directory , _cbfv_files [ \"megnet16\" ]) with open ( megnet16_json ) as f : embedding_data = json . load ( f ) # Remove 'Null' key from megnet embedding del embedding_data [ \"Null\" ] elif embedding_name in _cbfv_names_others : _json = path . join ( data_directory , _cbfv_files [ embedding_name ]) with open ( _json ) as f : embedding_data = json . load ( f ) # Load a json file from a file specified in the input else : with open ( embedding_name ) as f : embedding_data = json . load ( f ) else : raise ( ValueError ( f \" { embedding_name } not in the data directory or not in directory.\" ) ) return Embedding ( embedding_data , embedding_name ) @staticmethod def from_json ( embedding_json ): \"\"\" Create an instance of the Embedding class from a json file. Args: embedding_json (str): Filepath of the json file \"\"\" # Need to add validation handling for JSONs in different formats with open ( embedding_json ) as f : embedding_data = json . load ( f ) return Embedding ( embedding_data ) @staticmethod def from_csv ( embedding_csv ): \"\"\" Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Args: embedding_csv (str): Filepath of the csv file \"\"\" # Need to add validation handling for csv files df = pd . read_csv ( embedding_csv ) elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } return Embedding ( embedding_data ) def as_dataframe ( self , columns : str = \"components\" ) -> pd . DataFrame : \"\"\" Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Args: columns (str): A string to specify if the columns are the vector components and the index is the elements (`columns='components') or the columns are the elements (`columns='elements'`). Returns: df (pandas.DataFrame): A pandas dataframe object \"\"\" embedding = self . embeddings df = pd . DataFrame ( embedding ) if columns == \"components\" : return df . T elif columns == \"elements\" : return df else : raise ( ValueError ( f \" { columns } is not a valid keyword argument. \" \"Choose either 'components' or 'elements\" ) ) def to ( self , fmt : str = \"\" , filename : Optional [ str ] = \"\" ): \"\"\" Output the embedding to a file. Args: fmt (str): The file format to output the embedding to. Options include \"json\" and \"csv\". filename (str): The name of the file to be outputted Returns: (str) if filename not specified, otherwise None. \"\"\" fmt = fmt . lower () if fmt == \"json\" or fnmatch . fnmatch ( filename , \"*.json\" ): j = json . dumps ( self . embeddings , cls = NumpyEncoder ) if filename : if not filename . endswith ( \".json\" ): filename = filename + \".json\" with open ( filename , \"w\" ) as file : file . write ( j ) else : return j elif fmt == \"csv\" or fnmatch . fnmatch ( filename , \"*.csv\" ): if filename : if not filename . endswith ( \".csv\" ): filename = filename + \".csv\" self . as_dataframe () . to_csv ( filename , index_label = \"element\" ) else : return self . as_dataframe () . to_csv ( index_label = \"element\" ) else : raise ValueError ( f \" { str ( fmt ) } is an invalid file format\" ) @property def element_list ( self ) -> list : \"\"\"Return the elements of the embedding.\"\"\" return list ( self . embeddings . keys ()) def remove_elements ( self , elements : Union [ str , List [ str ]], inplace : bool = False ): # TO-DO allow removal by atomic numbers \"\"\" Remove elements from the Embedding instance. Args: elements (str,list(str)): An element symbol or a list of element symbols inplace (bool): If True, elements are removed from the Embedding instance. If false, the original embedding instance is unchanged and a new embedding instance with the elements removed is created. \"\"\" if inplace : if isinstance ( elements , str ): del self . embeddings [ elements ] elif isinstance ( elements , list ): for el in elements : del self . embeddings [ el ] return None else : embeddings_copy = self . embeddings . copy () if isinstance ( elements , str ): del embeddings_copy [ elements ] elif isinstance ( elements , list ): for el in elements : del embeddings_copy [ el ] return Embedding ( embeddings_copy , self . embedding_name ) def citation ( self ) -> List [ str ]: \"\"\"Return a citation for the embedding.\"\"\" if self . embedding_name in [ \"magpie\" , \"magpie_sc\" ]: citation = [ \"@article{ward2016general,\" \"title={A general-purpose machine learning framework for \" \"predicting properties of inorganic materials},\" \"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \" \"and Wolverton, Christopher},\" \"journal={npj Computational Materials},\" \"volume= {2} ,\" \"number= {1} ,\" \"pages={1--7},\" \"year= {2016} ,\" \"publisher={Nature Publishing Group}}\" ] elif self . embedding_name == \"mat2vec\" : citation = [ \"@article{tshitoyan2019unsupervised,\" \"title={Unsupervised word embeddings capture latent knowledge \" \"from materials science literature},\" \"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \" \"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \" \"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\" \"journal= {Nature} ,\" \"volume= {571} ,\" \"number= {7763} ,\" \"pages={95--98},\" \"year= {2019} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"matscholar\" : citation = [ \"@article{weston2019named,\" \"title={Named entity recognition and normalization applied to \" \"large-scale information extraction from the materials \" \"science literature},\" \"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \" \"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \" \"Ceder, Gerbrand and Jain, Anubhav},\" \"journal={Journal of chemical information and modeling},\" \"volume= {59} ,\" \"number= {9} ,\" \"pages={3692--3702},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"megnet16\" : citation = [ \"@article{chen2019graph,\" \"title={Graph networks as a universal machine learning framework \" \"for molecules and crystals},\" \"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \" \"Zheng, Chen and Ong, Shyue Ping},\" \"journal={Chemistry of Materials},\" \"volume= {31} ,\" \"number= {9} ,\" \"pages={3564--3572},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name in [ \"oliynyk\" , \"oliynyk_sc\" ]: citation = [ \" @article{oliynyk2016high,\" \"title={High-throughput machine-learning-driven synthesis \" \"of full-Heusler compounds},\" \"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \" \"Ghadbeigi, Leila and Gaultois, Michael W and \" \"Meredig, Bryce and Mar, Arthur},\" \"journal={Chemistry of Materials},\" \"volume= {28} ,\" \"number= {20} ,\" \"pages={7324--7331},\" \"year= {2016} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"skipatom\" : citation = [ \"@article{antunes2022distributed,\" \"title={Distributed representations of atoms and materials \" \"for machine learning},\" \"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\" \"journal={npj Computational Materials},\" \"volume= {8} ,\" \"number= {1} ,\" \"pages={1--9},\" \"year= {2022} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"mod_petti\" : citation = [ \"@article{glawe2016optimal,\" \"title={The optimal one dimensional periodic table: \" \"a modified Pettifor chemical scale from data mining},\" \"author={Glawe, Henning and Sanna, Antonio and Gross, \" \"EKU and Marques, Miguel AL},\" \"journal={New Journal of Physics},\" \"volume= {18} ,\" \"number= {9} ,\" \"pages= {093011} ,\" \"year= {2016} ,\" \"publisher={IOP Publishing} }\" ] else : citation = [] return citation def _is_el_in_embedding ( self , el : str ) -> bool : \"\"\" Check if an element is in the `Embedding` object. Args: el (str): An element symbol Returns: bool: True if el is in the Embedding, else False \"\"\" if el in self . element_list : return True else : return False @property def element_groups_dict ( self ) -> Dict [ str , str ]: \"\"\" Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} \"\"\" with open ( path . join ( data_directory , \"element_data/element_group.json\" )) as f : _dict = json . load ( f ) return { i : _dict [ i ] for i in self . element_list } def create_pairs ( self ): \"\"\"Create all possible pairs of elements.\"\"\" ele_list = self . element_list ele_pairs = combinations_with_replacement ( ele_list , 2 ) return ele_pairs def correlation_df ( self ) -> pd . DataFrame : \"\"\"Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : pearson = pearsonr ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) dist = norm ( self . embeddings [ ele1 ] - self . embeddings [ ele2 ]) table . append (( ele1 , ele2 , pearson [ 0 ], dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , pearson [ 0 ], dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , \"pearson_corr\" , \"euclid_dist\" , ], ) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df = corr_df [ [ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"euclid_dist\" , \"pearson_corr\" , ] ] return corr_df def compute_correlation_metric ( self , ele1 : str , ele2 : str , metric : str = \"pearson\" ) -> Union [ PearsonRResult , SpearmanrResult , float ]: \"\"\" Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a correlation metric. Options are \"spearman\", \"pearson\" and \"cosine\". Returns: PearsonResult | SpearmanrResult | float: correlation/similarity metric \"\"\" # Define the allowable metrics scipy_corrs = { \"pearson\" : pearsonr , \"spearman\" : spearmanr } if metric in scipy_corrs : return scipy_corrs [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" : return cosine_similarity ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) def compute_distance_metric ( self , ele1 : str , ele2 : str , metric : str = \"euclidean\" ) -> float : \"\"\" Compute distance metric between two vectors. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy * cosine (cosine distance) Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a distance metric Returns: distance (float): distance between embedding vectors \"\"\" # Define the allowable metrics scikit_metrics = [ \"euclidean\" , \"manhattan\" , \"chebyshev\" ] scipy_metrics = { \"wasserstein\" : wasserstein_distance , \"energy\" : energy_distance } valid_metrics = scikit_metrics + list ( scipy_metrics . keys ()) + [ \"cosine\" ] # Validate if the elements are within the embedding vector if not all ([ self . _is_el_in_embedding ( ele1 ), self . _is_el_in_embedding ( ele2 )]): if not self . _is_el_in_embedding ( ele1 ): print ( f \" { ele1 } is not an element included within the atomic embeddings\" ) raise ValueError elif not self . _is_el_in_embedding ( ele2 ): print ( f \" { ele2 } is not an element included within the atomic embeddings\" ) raise ValueError # Compute the distance measure if metric in scikit_metrics : distance = DistanceMetric . get_metric ( metric ) return distance . pairwise ( self . embeddings [ ele1 ] . reshape ( 1 , - 1 ), self . embeddings [ ele2 ] . reshape ( 1 , - 1 ), )[ 0 ][ 0 ] elif metric in scipy_metrics . keys (): return scipy_metrics [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" or metric == \"cosine_distance\" : return cosine_distance ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) else : print ( \"Invalid distance metric.\" f \"Use one of the following metrics: { valid_metrics } \" ) raise ValueError def pearson_pivot_table ( self ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) corr_df = self . correlation_df () pearson_pivot = corr_df . pivot_table ( values = \"pearson_corr\" , index = \"mend_1\" , columns = \"mend_2\" ) return pearson_pivot def distance_correlation_df ( self , metric : str = \"euclidean\" ) -> pd . DataFrame : \"\"\" Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy Args: metric (str): A distance metric. Returns: df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric]. \"\"\" ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : dist = self . compute_distance_metric ( ele1 , ele2 , metric = metric ) table . append (( ele1 , ele2 , dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , metric ]) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] Z_1 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_1\" ]] Z_2 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df [ \"Z_1\" ] = Z_1 corr_df [ \"Z_2\" ] = Z_2 corr_df = corr_df [[ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"Z_1\" , \"Z_2\" , metric ]] return corr_df def distance_pivot_table ( self , metric : str = \"euclidean\" , sortby : str = \"mendeleev\" ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Args: metric (str): A distance metric. sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\". Returns: distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table. \"\"\" corr_df = self . distance_correlation_df ( metric = metric ) if sortby == \"mendeleev\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"mend_1\" , columns = \"mend_2\" ) return distance_pivot elif sortby == \"atomic_number\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"Z_1\" , columns = \"Z_2\" ) return distance_pivot def plot_pearson_correlation ( self , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pearson correlation values. Args: figsize (tuple): A tuple of (width, height). **kwargs: Other keyword arguments to be passed to sns.heatmap Returns: ax (matplotlib Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) pearson_pivot = self . pearson_pivot_table () plt . figure ( figsize = figsize ) ax = sns . heatmap ( pearson_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax def plot_distance_correlation ( self , metric : str = \"euclidean\" , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pairwise distance metrics. Args: metric (str): A valid distance metric figsize (tuple): A tuple of (width, height) Returns: ax (matplotlib.axes.Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) distance_pivot = self . distance_pivot_table ( metric = metric ) plt . figure ( figsize = figsize ) ax = sns . heatmap ( distance_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax def calculate ( self , mode : str = \"all\" ) -> None : \"\"\" Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Args: mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"` will calculate all available distance and correlation metrics; `mode=\"correlation\"` will only calculate correlation metrics and `mode=\"distance\"` will only calculate distance metrics. Returns: None \"\"\" ele_pairs = self . create_pairs () table = [] # columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"] for ele1 , ele2 in ele_pairs : temp_dict = { \"element_1\" : ele1 , \"element_2\" : ele2 } table . append ( temp_dict ) pass def calculate_PC ( self , n_components : int , ** kwargs ): \"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\" pass def calculate_tSNE ( self , ** kwargs ): \"\"\"Calculate t-SNE components.\"\"\" pass def calculate_UMAP ( self , ** kwargs ): \"\"\"Calculate UMAP embeddings.\"\"\" pass def plot_PCA_2D ( self , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a PCA plot of the atomic embedding. Args: figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) pca = decomposition . PCA ( n_components = 2 ) # project to 2 dimensions pca . fit ( embeddings_array ) X = pca . transform ( embeddings_array ) pca_dim1 = X [:, 0 ] pca_dim2 = X [:, 1 ] # Create a dataframe to store the dimensions, labels and group info for the PCA pca_df = pd . DataFrame ( { \"pca_dim1\" : pca_dim1 , \"pca_dim2\" : pca_dim2 , \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"pca_dim1\" , y = \"pca_dim2\" , data = pca_df , hue = points_hue , s = points_size , ** kwargs , ax = ax , ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) for i in range ( len ( X )): plt . text ( x = pca_dim1 [ i ], y = pca_dim2 [ i ], s = element_array [ i ]) return plt def plot_tSNE ( self , n_components : str = 2 , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a t-SNE plot of the atomic embedding. Args: n_components (int): Number of t-SNE components to plot. figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) tsne = TSNE ( n_components ) tsne_result = tsne . fit_transform ( embeddings_array ) tsne_df = pd . DataFrame ( { \"tsne_dim1\" : tsne_result [:, 0 ], \"tsne_dim2\" : tsne_result [:, 1 ], \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) # Create the t-SNE plot fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"tsne_dim1\" , y = \"tsne_dim2\" , data = tsne_df , hue = points_hue , s = points_size , ax = ax , ) # lim = (tsne_result.min()-5, tsne_result.max()+5) # ax.set_xlim(lim) # ax.set_ylim(lim) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) # Label the points for i in range ( tsne_df . shape [ 0 ]): plt . text ( x = tsne_df [ \"tsne_dim1\" ][ i ], y = tsne_df [ \"tsne_dim2\" ][ i ], s = tsne_df [ \"element\" ][ i ], ) return plt __init__ ( embeddings , embedding_name = None ) Initialise the Embedding class. Parameters: Name Type Description Default embeddings dict A {element_symbol: vector} dictionary required embedding_name str The name of the elemental representation None Source code in AtomicEmbeddings/core.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , embeddings : dict , embedding_name : Optional [ str ] = None ): \"\"\"Initialise the Embedding class. Args: embeddings (dict): A {element_symbol: vector} dictionary embedding_name (str): The name of the elemental representation \"\"\" self . embeddings = embeddings self . embedding_name = embedding_name # Grab a random value from the embedding vector _rand_embed = random . choice ( list ( self . embeddings . values ())) # Convert embeddings to numpy array if not already a numpy array if not isinstance ( _rand_embed , np . ndarray ): self . embeddings = { ele : np . array ( self . embeddings [ ele ]) for ele in self . embeddings } # Determines if the embedding vector has a length attribute # (i.e. is not a scalar int or float) # If the 'vector' is a scalar/float, the representation is linear (dim=1) if hasattr ( _rand_embed , \"__len__\" ) and ( not isinstance ( _rand_embed , str )): self . dim : int = len ( random . choice ( list ( self . embeddings . values ()))) else : self . dim : int = int ( 1 ) # Dummy initialisation for results self . _data = [] as_dataframe ( columns = 'components' ) Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Parameters: Name Type Description Default columns str A string to specify if the columns are the vector components 'components' Returns: Name Type Description df pandas . DataFrame A pandas dataframe object Source code in AtomicEmbeddings/core.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def as_dataframe ( self , columns : str = \"components\" ) -> pd . DataFrame : \"\"\" Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Args: columns (str): A string to specify if the columns are the vector components and the index is the elements (`columns='components') or the columns are the elements (`columns='elements'`). Returns: df (pandas.DataFrame): A pandas dataframe object \"\"\" embedding = self . embeddings df = pd . DataFrame ( embedding ) if columns == \"components\" : return df . T elif columns == \"elements\" : return df else : raise ( ValueError ( f \" { columns } is not a valid keyword argument. \" \"Choose either 'components' or 'elements\" ) ) calculate ( mode = 'all' ) Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Parameters: Name Type Description Default mode str Specifies which pairwise statistics to calculate. mode=\"all\" will calculate all available distance and correlation metrics; mode=\"correlation\" will only calculate correlation metrics and mode=\"distance\" will only calculate distance metrics. 'all' Returns: Type Description None None Source code in AtomicEmbeddings/core.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def calculate ( self , mode : str = \"all\" ) -> None : \"\"\" Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Args: mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"` will calculate all available distance and correlation metrics; `mode=\"correlation\"` will only calculate correlation metrics and `mode=\"distance\"` will only calculate distance metrics. Returns: None \"\"\" ele_pairs = self . create_pairs () table = [] # columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"] for ele1 , ele2 in ele_pairs : temp_dict = { \"element_1\" : ele1 , \"element_2\" : ele2 } table . append ( temp_dict ) pass calculate_PC ( n_components , ** kwargs ) Calculate the principal componenets (PC) of the embeddings. Source code in AtomicEmbeddings/core.py 741 742 743 def calculate_PC ( self , n_components : int , ** kwargs ): \"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\" pass calculate_UMAP ( ** kwargs ) Calculate UMAP embeddings. Source code in AtomicEmbeddings/core.py 749 750 751 def calculate_UMAP ( self , ** kwargs ): \"\"\"Calculate UMAP embeddings.\"\"\" pass calculate_tSNE ( ** kwargs ) Calculate t-SNE components. Source code in AtomicEmbeddings/core.py 745 746 747 def calculate_tSNE ( self , ** kwargs ): \"\"\"Calculate t-SNE components.\"\"\" pass citation () Return a citation for the embedding. Source code in AtomicEmbeddings/core.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def citation ( self ) -> List [ str ]: \"\"\"Return a citation for the embedding.\"\"\" if self . embedding_name in [ \"magpie\" , \"magpie_sc\" ]: citation = [ \"@article{ward2016general,\" \"title={A general-purpose machine learning framework for \" \"predicting properties of inorganic materials},\" \"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \" \"and Wolverton, Christopher},\" \"journal={npj Computational Materials},\" \"volume= {2} ,\" \"number= {1} ,\" \"pages={1--7},\" \"year= {2016} ,\" \"publisher={Nature Publishing Group}}\" ] elif self . embedding_name == \"mat2vec\" : citation = [ \"@article{tshitoyan2019unsupervised,\" \"title={Unsupervised word embeddings capture latent knowledge \" \"from materials science literature},\" \"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \" \"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \" \"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\" \"journal= {Nature} ,\" \"volume= {571} ,\" \"number= {7763} ,\" \"pages={95--98},\" \"year= {2019} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"matscholar\" : citation = [ \"@article{weston2019named,\" \"title={Named entity recognition and normalization applied to \" \"large-scale information extraction from the materials \" \"science literature},\" \"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \" \"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \" \"Ceder, Gerbrand and Jain, Anubhav},\" \"journal={Journal of chemical information and modeling},\" \"volume= {59} ,\" \"number= {9} ,\" \"pages={3692--3702},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"megnet16\" : citation = [ \"@article{chen2019graph,\" \"title={Graph networks as a universal machine learning framework \" \"for molecules and crystals},\" \"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \" \"Zheng, Chen and Ong, Shyue Ping},\" \"journal={Chemistry of Materials},\" \"volume= {31} ,\" \"number= {9} ,\" \"pages={3564--3572},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name in [ \"oliynyk\" , \"oliynyk_sc\" ]: citation = [ \" @article{oliynyk2016high,\" \"title={High-throughput machine-learning-driven synthesis \" \"of full-Heusler compounds},\" \"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \" \"Ghadbeigi, Leila and Gaultois, Michael W and \" \"Meredig, Bryce and Mar, Arthur},\" \"journal={Chemistry of Materials},\" \"volume= {28} ,\" \"number= {20} ,\" \"pages={7324--7331},\" \"year= {2016} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"skipatom\" : citation = [ \"@article{antunes2022distributed,\" \"title={Distributed representations of atoms and materials \" \"for machine learning},\" \"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\" \"journal={npj Computational Materials},\" \"volume= {8} ,\" \"number= {1} ,\" \"pages={1--9},\" \"year= {2022} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"mod_petti\" : citation = [ \"@article{glawe2016optimal,\" \"title={The optimal one dimensional periodic table: \" \"a modified Pettifor chemical scale from data mining},\" \"author={Glawe, Henning and Sanna, Antonio and Gross, \" \"EKU and Marques, Miguel AL},\" \"journal={New Journal of Physics},\" \"volume= {18} ,\" \"number= {9} ,\" \"pages= {093011} ,\" \"year= {2016} ,\" \"publisher={IOP Publishing} }\" ] else : citation = [] return citation compute_correlation_metric ( ele1 , ele2 , metric = 'pearson' ) Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Parameters: Name Type Description Default ele1 str element symbol required ele2 str element symbol required metric str name of a correlation metric. 'pearson' Returns: Type Description Union [ PearsonRResult , SpearmanrResult , float ] PearsonResult | SpearmanrResult | float: correlation/similarity metric Source code in AtomicEmbeddings/core.py 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def compute_correlation_metric ( self , ele1 : str , ele2 : str , metric : str = \"pearson\" ) -> Union [ PearsonRResult , SpearmanrResult , float ]: \"\"\" Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a correlation metric. Options are \"spearman\", \"pearson\" and \"cosine\". Returns: PearsonResult | SpearmanrResult | float: correlation/similarity metric \"\"\" # Define the allowable metrics scipy_corrs = { \"pearson\" : pearsonr , \"spearman\" : spearmanr } if metric in scipy_corrs : return scipy_corrs [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" : return cosine_similarity ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) compute_distance_metric ( ele1 , ele2 , metric = 'euclidean' ) Compute distance metric between two vectors. Allowed metrics: euclidean manhattan chebyshev wasserstein energy cosine (cosine distance) Parameters: Name Type Description Default ele1 str element symbol required ele2 str element symbol required metric str name of a distance metric 'euclidean' Returns: Name Type Description distance float distance between embedding vectors Source code in AtomicEmbeddings/core.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 def compute_distance_metric ( self , ele1 : str , ele2 : str , metric : str = \"euclidean\" ) -> float : \"\"\" Compute distance metric between two vectors. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy * cosine (cosine distance) Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a distance metric Returns: distance (float): distance between embedding vectors \"\"\" # Define the allowable metrics scikit_metrics = [ \"euclidean\" , \"manhattan\" , \"chebyshev\" ] scipy_metrics = { \"wasserstein\" : wasserstein_distance , \"energy\" : energy_distance } valid_metrics = scikit_metrics + list ( scipy_metrics . keys ()) + [ \"cosine\" ] # Validate if the elements are within the embedding vector if not all ([ self . _is_el_in_embedding ( ele1 ), self . _is_el_in_embedding ( ele2 )]): if not self . _is_el_in_embedding ( ele1 ): print ( f \" { ele1 } is not an element included within the atomic embeddings\" ) raise ValueError elif not self . _is_el_in_embedding ( ele2 ): print ( f \" { ele2 } is not an element included within the atomic embeddings\" ) raise ValueError # Compute the distance measure if metric in scikit_metrics : distance = DistanceMetric . get_metric ( metric ) return distance . pairwise ( self . embeddings [ ele1 ] . reshape ( 1 , - 1 ), self . embeddings [ ele2 ] . reshape ( 1 , - 1 ), )[ 0 ][ 0 ] elif metric in scipy_metrics . keys (): return scipy_metrics [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" or metric == \"cosine_distance\" : return cosine_distance ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) else : print ( \"Invalid distance metric.\" f \"Use one of the following metrics: { valid_metrics } \" ) raise ValueError correlation_df () Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. Source code in AtomicEmbeddings/core.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def correlation_df ( self ) -> pd . DataFrame : \"\"\"Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : pearson = pearsonr ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) dist = norm ( self . embeddings [ ele1 ] - self . embeddings [ ele2 ]) table . append (( ele1 , ele2 , pearson [ 0 ], dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , pearson [ 0 ], dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , \"pearson_corr\" , \"euclid_dist\" , ], ) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df = corr_df [ [ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"euclid_dist\" , \"pearson_corr\" , ] ] return corr_df create_pairs () Create all possible pairs of elements. Source code in AtomicEmbeddings/core.py 432 433 434 435 436 def create_pairs ( self ): \"\"\"Create all possible pairs of elements.\"\"\" ele_list = self . element_list ele_pairs = combinations_with_replacement ( ele_list , 2 ) return ele_pairs distance_correlation_df ( metric = 'euclidean' ) Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: euclidean manhattan chebyshev wasserstein energy Parameters: Name Type Description Default metric str A distance metric. 'euclidean' Returns: Name Type Description df pandas . DataFrame A dataframe with columns [\"ele_1\", \"ele_2\", metric]. Source code in AtomicEmbeddings/core.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 def distance_correlation_df ( self , metric : str = \"euclidean\" ) -> pd . DataFrame : \"\"\" Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy Args: metric (str): A distance metric. Returns: df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric]. \"\"\" ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : dist = self . compute_distance_metric ( ele1 , ele2 , metric = metric ) table . append (( ele1 , ele2 , dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , metric ]) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] Z_1 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_1\" ]] Z_2 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df [ \"Z_1\" ] = Z_1 corr_df [ \"Z_2\" ] = Z_2 corr_df = corr_df [[ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"Z_1\" , \"Z_2\" , metric ]] return corr_df distance_pivot_table ( metric = 'euclidean' , sortby = 'mendeleev' ) Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Parameters: Name Type Description Default metric str A distance metric. 'euclidean' sortby str Sort the pivot table by either \"mendeleev\" or \"atomic_number\". 'mendeleev' Returns: Name Type Description distance_pivot pandas . DataFrame A pandas DataFrame pivot table. Source code in AtomicEmbeddings/core.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 def distance_pivot_table ( self , metric : str = \"euclidean\" , sortby : str = \"mendeleev\" ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Args: metric (str): A distance metric. sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\". Returns: distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table. \"\"\" corr_df = self . distance_correlation_df ( metric = metric ) if sortby == \"mendeleev\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"mend_1\" , columns = \"mend_2\" ) return distance_pivot elif sortby == \"atomic_number\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"Z_1\" , columns = \"Z_2\" ) return distance_pivot element_groups_dict () property Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} Source code in AtomicEmbeddings/core.py 420 421 422 423 424 425 426 427 428 429 430 @property def element_groups_dict ( self ) -> Dict [ str , str ]: \"\"\" Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} \"\"\" with open ( path . join ( data_directory , \"element_data/element_group.json\" )) as f : _dict = json . load ( f ) return { i : _dict [ i ] for i in self . element_list } element_list () property Return the elements of the embedding. Source code in AtomicEmbeddings/core.py 261 262 263 264 @property def element_list ( self ) -> list : \"\"\"Return the elements of the embedding.\"\"\" return list ( self . embeddings . keys ()) from_csv ( embedding_csv ) staticmethod Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Parameters: Name Type Description Default embedding_csv str Filepath of the csv file required Source code in AtomicEmbeddings/core.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @staticmethod def from_csv ( embedding_csv ): \"\"\" Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Args: embedding_csv (str): Filepath of the csv file \"\"\" # Need to add validation handling for csv files df = pd . read_csv ( embedding_csv ) elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } return Embedding ( embedding_data ) from_json ( embedding_json ) staticmethod Create an instance of the Embedding class from a json file. Parameters: Name Type Description Default embedding_json str Filepath of the json file required Source code in AtomicEmbeddings/core.py 164 165 166 167 168 169 170 171 172 173 174 175 @staticmethod def from_json ( embedding_json ): \"\"\" Create an instance of the Embedding class from a json file. Args: embedding_json (str): Filepath of the json file \"\"\" # Need to add validation handling for JSONs in different formats with open ( embedding_json ) as f : embedding_data = json . load ( f ) return Embedding ( embedding_data ) load_data ( embedding_name = None ) staticmethod Create an instance of the Embedding class from a default embedding file. The default embeddings are in the table below: Name str_name Magpie magpie Magpie (scaled) magpie_sc Mat2Vec mat2vec Matscholar matscholar Megnet (16 dimensions) megnet16 Modified pettifor scale mod_petti Oliynyk oliynyk Oliynyk (scaled) oliynyk_sc Random (200 dimensions) random_200 SkipAtom skipatom Parameters: Name Type Description Default embedding_name str The str_name of an embedding file. None Returns: Name Type Description Embedding class: Embedding instance. Source code in AtomicEmbeddings/core.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @staticmethod def load_data ( embedding_name : Optional [ str ] = None ): \"\"\" Create an instance of the `Embedding` class from a default embedding file. The default embeddings are in the table below: | **Name** | **str_name** | |-------------------------|--------------| | Magpie | magpie | | Magpie (scaled) | magpie_sc | | Mat2Vec | mat2vec | | Matscholar | matscholar | | Megnet (16 dimensions) | megnet16 | | Modified pettifor scale | mod_petti | | Oliynyk | oliynyk | | Oliynyk (scaled) | oliynyk_sc | | Random (200 dimensions) | random_200 | | SkipAtom | skipatom | Args: embedding_name (str): The str_name of an embedding file. Returns: Embedding :class:`Embedding` instance. \"\"\" _cbfv_files = { \"magpie\" : \"magpie.csv\" , \"magpie_sc\" : \"magpie_sc.json\" , \"mat2vec\" : \"mat2vec.csv\" , \"matscholar\" : \"matscholar-embedding.json\" , \"megnet16\" : \"megnet16.json\" , \"mod_petti\" : \"mod_petti.json\" , \"oliynyk\" : \"oliynyk.json\" , \"oliynyk_sc\" : \"oliynyk_sc.json\" , \"random_200\" : \"random_200_new.csv\" , \"skipatom\" : \"skipatom_20201009_induced.csv\" , } _cbfv_names = list ( _cbfv_files . keys ()) _cbfv_names_others = [ i for i in _cbfv_names if i not in [ \"skipatom\" , \"random_200\" , \"megnet16\" , \"magpie\" , \"mat2vec\" ] ] # Get the embeddings if embedding_name in _cbfv_files : if embedding_name in [ \"skipatom\" , \"random_200\" , \"magpie\" , \"mat2vec\" ]: _csv = path . join ( data_directory , _cbfv_files [ embedding_name ]) df = pd . read_csv ( _csv ) # Convert df to a dictionary of (ele:embeddings) pairs elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } elif embedding_name == \"megnet16\" : megnet16_json = path . join ( data_directory , _cbfv_files [ \"megnet16\" ]) with open ( megnet16_json ) as f : embedding_data = json . load ( f ) # Remove 'Null' key from megnet embedding del embedding_data [ \"Null\" ] elif embedding_name in _cbfv_names_others : _json = path . join ( data_directory , _cbfv_files [ embedding_name ]) with open ( _json ) as f : embedding_data = json . load ( f ) # Load a json file from a file specified in the input else : with open ( embedding_name ) as f : embedding_data = json . load ( f ) else : raise ( ValueError ( f \" { embedding_name } not in the data directory or not in directory.\" ) ) return Embedding ( embedding_data , embedding_name ) pearson_pivot_table () Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. Source code in AtomicEmbeddings/core.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def pearson_pivot_table ( self ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) corr_df = self . correlation_df () pearson_pivot = corr_df . pivot_table ( values = \"pearson_corr\" , index = \"mend_1\" , columns = \"mend_2\" ) return pearson_pivot plot_PCA_2D ( figsize = ( 16 , 12 ), points_hue = 'group' , points_size = 200 , ** kwargs ) Plot a PCA plot of the atomic embedding. Parameters: Name Type Description Default figsize tuple A tuple of (width, height) (16, 12) points_size float The marker size 200 Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the PCA plot Source code in AtomicEmbeddings/core.py 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 def plot_PCA_2D ( self , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a PCA plot of the atomic embedding. Args: figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) pca = decomposition . PCA ( n_components = 2 ) # project to 2 dimensions pca . fit ( embeddings_array ) X = pca . transform ( embeddings_array ) pca_dim1 = X [:, 0 ] pca_dim2 = X [:, 1 ] # Create a dataframe to store the dimensions, labels and group info for the PCA pca_df = pd . DataFrame ( { \"pca_dim1\" : pca_dim1 , \"pca_dim2\" : pca_dim2 , \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"pca_dim1\" , y = \"pca_dim2\" , data = pca_df , hue = points_hue , s = points_size , ** kwargs , ax = ax , ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) for i in range ( len ( X )): plt . text ( x = pca_dim1 [ i ], y = pca_dim2 [ i ], s = element_array [ i ]) return plt plot_distance_correlation ( metric = 'euclidean' , figsize = ( 24 , 24 ), ** kwargs ) Plot the heatmap of the pairwise distance metrics. Parameters: Name Type Description Default metric str A valid distance metric 'euclidean' figsize tuple A tuple of (width, height) (24, 24) Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the heatmap Source code in AtomicEmbeddings/core.py 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def plot_distance_correlation ( self , metric : str = \"euclidean\" , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pairwise distance metrics. Args: metric (str): A valid distance metric figsize (tuple): A tuple of (width, height) Returns: ax (matplotlib.axes.Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) distance_pivot = self . distance_pivot_table ( metric = metric ) plt . figure ( figsize = figsize ) ax = sns . heatmap ( distance_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax plot_pearson_correlation ( figsize = ( 24 , 24 ), ** kwargs ) Plot the heatmap of the pearson correlation values. Parameters: Name Type Description Default figsize tuple A tuple of (width, height). (24, 24) **kwargs Other keyword arguments to be passed to sns.heatmap {} Returns: Name Type Description ax matplotlib Axes An Axes object with the heatmap Source code in AtomicEmbeddings/core.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 def plot_pearson_correlation ( self , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pearson correlation values. Args: figsize (tuple): A tuple of (width, height). **kwargs: Other keyword arguments to be passed to sns.heatmap Returns: ax (matplotlib Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) pearson_pivot = self . pearson_pivot_table () plt . figure ( figsize = figsize ) ax = sns . heatmap ( pearson_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax plot_tSNE ( n_components = 2 , figsize = ( 16 , 12 ), points_hue = 'group' , points_size = 200 , ** kwargs ) Plot a t-SNE plot of the atomic embedding. Parameters: Name Type Description Default n_components int Number of t-SNE components to plot. 2 figsize tuple A tuple of (width, height) (16, 12) points_size float The marker size 200 Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the PCA plot Source code in AtomicEmbeddings/core.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 def plot_tSNE ( self , n_components : str = 2 , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a t-SNE plot of the atomic embedding. Args: n_components (int): Number of t-SNE components to plot. figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) tsne = TSNE ( n_components ) tsne_result = tsne . fit_transform ( embeddings_array ) tsne_df = pd . DataFrame ( { \"tsne_dim1\" : tsne_result [:, 0 ], \"tsne_dim2\" : tsne_result [:, 1 ], \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) # Create the t-SNE plot fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"tsne_dim1\" , y = \"tsne_dim2\" , data = tsne_df , hue = points_hue , s = points_size , ax = ax , ) # lim = (tsne_result.min()-5, tsne_result.max()+5) # ax.set_xlim(lim) # ax.set_ylim(lim) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) # Label the points for i in range ( tsne_df . shape [ 0 ]): plt . text ( x = tsne_df [ \"tsne_dim1\" ][ i ], y = tsne_df [ \"tsne_dim2\" ][ i ], s = tsne_df [ \"element\" ][ i ], ) return plt remove_elements ( elements , inplace = False ) Remove elements from the Embedding instance. Parameters: Name Type Description Default elements str,list(str An element symbol or a list of element symbols required inplace bool If True, elements are removed from the Embedding instance. False Source code in AtomicEmbeddings/core.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def remove_elements ( self , elements : Union [ str , List [ str ]], inplace : bool = False ): # TO-DO allow removal by atomic numbers \"\"\" Remove elements from the Embedding instance. Args: elements (str,list(str)): An element symbol or a list of element symbols inplace (bool): If True, elements are removed from the Embedding instance. If false, the original embedding instance is unchanged and a new embedding instance with the elements removed is created. \"\"\" if inplace : if isinstance ( elements , str ): del self . embeddings [ elements ] elif isinstance ( elements , list ): for el in elements : del self . embeddings [ el ] return None else : embeddings_copy = self . embeddings . copy () if isinstance ( elements , str ): del embeddings_copy [ elements ] elif isinstance ( elements , list ): for el in elements : del embeddings_copy [ el ] return Embedding ( embeddings_copy , self . embedding_name ) to ( fmt = '' , filename = '' ) Output the embedding to a file. Parameters: Name Type Description Default fmt str The file format to output the embedding to. '' filename str The name of the file to be outputted '' Returns: Type Description (str) if filename not specified, otherwise None. Source code in AtomicEmbeddings/core.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def to ( self , fmt : str = \"\" , filename : Optional [ str ] = \"\" ): \"\"\" Output the embedding to a file. Args: fmt (str): The file format to output the embedding to. Options include \"json\" and \"csv\". filename (str): The name of the file to be outputted Returns: (str) if filename not specified, otherwise None. \"\"\" fmt = fmt . lower () if fmt == \"json\" or fnmatch . fnmatch ( filename , \"*.json\" ): j = json . dumps ( self . embeddings , cls = NumpyEncoder ) if filename : if not filename . endswith ( \".json\" ): filename = filename + \".json\" with open ( filename , \"w\" ) as file : file . write ( j ) else : return j elif fmt == \"csv\" or fnmatch . fnmatch ( filename , \"*.csv\" ): if filename : if not filename . endswith ( \".csv\" ): filename = filename + \".csv\" self . as_dataframe () . to_csv ( filename , index_label = \"element\" ) else : return self . as_dataframe () . to_csv ( index_label = \"element\" ) else : raise ValueError ( f \" { str ( fmt ) } is an invalid file format\" )","title":"Core module"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding","text":"Represent an elemental representation. To load an embedding distributed from the package use the load_data() method. Works like a standard python dictionary. The keys are {element: vector} pairs. Adds a few convenience methods related to elemental representations. Source code in AtomicEmbeddings/core.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 class Embedding : \"\"\" Represent an elemental representation. To load an embedding distributed from the package use the load_data() method. Works like a standard python dictionary. The keys are {element: vector} pairs. Adds a few convenience methods related to elemental representations. \"\"\" def __init__ ( self , embeddings : dict , embedding_name : Optional [ str ] = None ): \"\"\"Initialise the Embedding class. Args: embeddings (dict): A {element_symbol: vector} dictionary embedding_name (str): The name of the elemental representation \"\"\" self . embeddings = embeddings self . embedding_name = embedding_name # Grab a random value from the embedding vector _rand_embed = random . choice ( list ( self . embeddings . values ())) # Convert embeddings to numpy array if not already a numpy array if not isinstance ( _rand_embed , np . ndarray ): self . embeddings = { ele : np . array ( self . embeddings [ ele ]) for ele in self . embeddings } # Determines if the embedding vector has a length attribute # (i.e. is not a scalar int or float) # If the 'vector' is a scalar/float, the representation is linear (dim=1) if hasattr ( _rand_embed , \"__len__\" ) and ( not isinstance ( _rand_embed , str )): self . dim : int = len ( random . choice ( list ( self . embeddings . values ()))) else : self . dim : int = int ( 1 ) # Dummy initialisation for results self . _data = [] @staticmethod def load_data ( embedding_name : Optional [ str ] = None ): \"\"\" Create an instance of the `Embedding` class from a default embedding file. The default embeddings are in the table below: | **Name** | **str_name** | |-------------------------|--------------| | Magpie | magpie | | Magpie (scaled) | magpie_sc | | Mat2Vec | mat2vec | | Matscholar | matscholar | | Megnet (16 dimensions) | megnet16 | | Modified pettifor scale | mod_petti | | Oliynyk | oliynyk | | Oliynyk (scaled) | oliynyk_sc | | Random (200 dimensions) | random_200 | | SkipAtom | skipatom | Args: embedding_name (str): The str_name of an embedding file. Returns: Embedding :class:`Embedding` instance. \"\"\" _cbfv_files = { \"magpie\" : \"magpie.csv\" , \"magpie_sc\" : \"magpie_sc.json\" , \"mat2vec\" : \"mat2vec.csv\" , \"matscholar\" : \"matscholar-embedding.json\" , \"megnet16\" : \"megnet16.json\" , \"mod_petti\" : \"mod_petti.json\" , \"oliynyk\" : \"oliynyk.json\" , \"oliynyk_sc\" : \"oliynyk_sc.json\" , \"random_200\" : \"random_200_new.csv\" , \"skipatom\" : \"skipatom_20201009_induced.csv\" , } _cbfv_names = list ( _cbfv_files . keys ()) _cbfv_names_others = [ i for i in _cbfv_names if i not in [ \"skipatom\" , \"random_200\" , \"megnet16\" , \"magpie\" , \"mat2vec\" ] ] # Get the embeddings if embedding_name in _cbfv_files : if embedding_name in [ \"skipatom\" , \"random_200\" , \"magpie\" , \"mat2vec\" ]: _csv = path . join ( data_directory , _cbfv_files [ embedding_name ]) df = pd . read_csv ( _csv ) # Convert df to a dictionary of (ele:embeddings) pairs elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } elif embedding_name == \"megnet16\" : megnet16_json = path . join ( data_directory , _cbfv_files [ \"megnet16\" ]) with open ( megnet16_json ) as f : embedding_data = json . load ( f ) # Remove 'Null' key from megnet embedding del embedding_data [ \"Null\" ] elif embedding_name in _cbfv_names_others : _json = path . join ( data_directory , _cbfv_files [ embedding_name ]) with open ( _json ) as f : embedding_data = json . load ( f ) # Load a json file from a file specified in the input else : with open ( embedding_name ) as f : embedding_data = json . load ( f ) else : raise ( ValueError ( f \" { embedding_name } not in the data directory or not in directory.\" ) ) return Embedding ( embedding_data , embedding_name ) @staticmethod def from_json ( embedding_json ): \"\"\" Create an instance of the Embedding class from a json file. Args: embedding_json (str): Filepath of the json file \"\"\" # Need to add validation handling for JSONs in different formats with open ( embedding_json ) as f : embedding_data = json . load ( f ) return Embedding ( embedding_data ) @staticmethod def from_csv ( embedding_csv ): \"\"\" Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Args: embedding_csv (str): Filepath of the csv file \"\"\" # Need to add validation handling for csv files df = pd . read_csv ( embedding_csv ) elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } return Embedding ( embedding_data ) def as_dataframe ( self , columns : str = \"components\" ) -> pd . DataFrame : \"\"\" Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Args: columns (str): A string to specify if the columns are the vector components and the index is the elements (`columns='components') or the columns are the elements (`columns='elements'`). Returns: df (pandas.DataFrame): A pandas dataframe object \"\"\" embedding = self . embeddings df = pd . DataFrame ( embedding ) if columns == \"components\" : return df . T elif columns == \"elements\" : return df else : raise ( ValueError ( f \" { columns } is not a valid keyword argument. \" \"Choose either 'components' or 'elements\" ) ) def to ( self , fmt : str = \"\" , filename : Optional [ str ] = \"\" ): \"\"\" Output the embedding to a file. Args: fmt (str): The file format to output the embedding to. Options include \"json\" and \"csv\". filename (str): The name of the file to be outputted Returns: (str) if filename not specified, otherwise None. \"\"\" fmt = fmt . lower () if fmt == \"json\" or fnmatch . fnmatch ( filename , \"*.json\" ): j = json . dumps ( self . embeddings , cls = NumpyEncoder ) if filename : if not filename . endswith ( \".json\" ): filename = filename + \".json\" with open ( filename , \"w\" ) as file : file . write ( j ) else : return j elif fmt == \"csv\" or fnmatch . fnmatch ( filename , \"*.csv\" ): if filename : if not filename . endswith ( \".csv\" ): filename = filename + \".csv\" self . as_dataframe () . to_csv ( filename , index_label = \"element\" ) else : return self . as_dataframe () . to_csv ( index_label = \"element\" ) else : raise ValueError ( f \" { str ( fmt ) } is an invalid file format\" ) @property def element_list ( self ) -> list : \"\"\"Return the elements of the embedding.\"\"\" return list ( self . embeddings . keys ()) def remove_elements ( self , elements : Union [ str , List [ str ]], inplace : bool = False ): # TO-DO allow removal by atomic numbers \"\"\" Remove elements from the Embedding instance. Args: elements (str,list(str)): An element symbol or a list of element symbols inplace (bool): If True, elements are removed from the Embedding instance. If false, the original embedding instance is unchanged and a new embedding instance with the elements removed is created. \"\"\" if inplace : if isinstance ( elements , str ): del self . embeddings [ elements ] elif isinstance ( elements , list ): for el in elements : del self . embeddings [ el ] return None else : embeddings_copy = self . embeddings . copy () if isinstance ( elements , str ): del embeddings_copy [ elements ] elif isinstance ( elements , list ): for el in elements : del embeddings_copy [ el ] return Embedding ( embeddings_copy , self . embedding_name ) def citation ( self ) -> List [ str ]: \"\"\"Return a citation for the embedding.\"\"\" if self . embedding_name in [ \"magpie\" , \"magpie_sc\" ]: citation = [ \"@article{ward2016general,\" \"title={A general-purpose machine learning framework for \" \"predicting properties of inorganic materials},\" \"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \" \"and Wolverton, Christopher},\" \"journal={npj Computational Materials},\" \"volume= {2} ,\" \"number= {1} ,\" \"pages={1--7},\" \"year= {2016} ,\" \"publisher={Nature Publishing Group}}\" ] elif self . embedding_name == \"mat2vec\" : citation = [ \"@article{tshitoyan2019unsupervised,\" \"title={Unsupervised word embeddings capture latent knowledge \" \"from materials science literature},\" \"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \" \"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \" \"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\" \"journal= {Nature} ,\" \"volume= {571} ,\" \"number= {7763} ,\" \"pages={95--98},\" \"year= {2019} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"matscholar\" : citation = [ \"@article{weston2019named,\" \"title={Named entity recognition and normalization applied to \" \"large-scale information extraction from the materials \" \"science literature},\" \"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \" \"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \" \"Ceder, Gerbrand and Jain, Anubhav},\" \"journal={Journal of chemical information and modeling},\" \"volume= {59} ,\" \"number= {9} ,\" \"pages={3692--3702},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"megnet16\" : citation = [ \"@article{chen2019graph,\" \"title={Graph networks as a universal machine learning framework \" \"for molecules and crystals},\" \"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \" \"Zheng, Chen and Ong, Shyue Ping},\" \"journal={Chemistry of Materials},\" \"volume= {31} ,\" \"number= {9} ,\" \"pages={3564--3572},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name in [ \"oliynyk\" , \"oliynyk_sc\" ]: citation = [ \" @article{oliynyk2016high,\" \"title={High-throughput machine-learning-driven synthesis \" \"of full-Heusler compounds},\" \"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \" \"Ghadbeigi, Leila and Gaultois, Michael W and \" \"Meredig, Bryce and Mar, Arthur},\" \"journal={Chemistry of Materials},\" \"volume= {28} ,\" \"number= {20} ,\" \"pages={7324--7331},\" \"year= {2016} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"skipatom\" : citation = [ \"@article{antunes2022distributed,\" \"title={Distributed representations of atoms and materials \" \"for machine learning},\" \"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\" \"journal={npj Computational Materials},\" \"volume= {8} ,\" \"number= {1} ,\" \"pages={1--9},\" \"year= {2022} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"mod_petti\" : citation = [ \"@article{glawe2016optimal,\" \"title={The optimal one dimensional periodic table: \" \"a modified Pettifor chemical scale from data mining},\" \"author={Glawe, Henning and Sanna, Antonio and Gross, \" \"EKU and Marques, Miguel AL},\" \"journal={New Journal of Physics},\" \"volume= {18} ,\" \"number= {9} ,\" \"pages= {093011} ,\" \"year= {2016} ,\" \"publisher={IOP Publishing} }\" ] else : citation = [] return citation def _is_el_in_embedding ( self , el : str ) -> bool : \"\"\" Check if an element is in the `Embedding` object. Args: el (str): An element symbol Returns: bool: True if el is in the Embedding, else False \"\"\" if el in self . element_list : return True else : return False @property def element_groups_dict ( self ) -> Dict [ str , str ]: \"\"\" Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} \"\"\" with open ( path . join ( data_directory , \"element_data/element_group.json\" )) as f : _dict = json . load ( f ) return { i : _dict [ i ] for i in self . element_list } def create_pairs ( self ): \"\"\"Create all possible pairs of elements.\"\"\" ele_list = self . element_list ele_pairs = combinations_with_replacement ( ele_list , 2 ) return ele_pairs def correlation_df ( self ) -> pd . DataFrame : \"\"\"Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : pearson = pearsonr ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) dist = norm ( self . embeddings [ ele1 ] - self . embeddings [ ele2 ]) table . append (( ele1 , ele2 , pearson [ 0 ], dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , pearson [ 0 ], dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , \"pearson_corr\" , \"euclid_dist\" , ], ) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df = corr_df [ [ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"euclid_dist\" , \"pearson_corr\" , ] ] return corr_df def compute_correlation_metric ( self , ele1 : str , ele2 : str , metric : str = \"pearson\" ) -> Union [ PearsonRResult , SpearmanrResult , float ]: \"\"\" Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a correlation metric. Options are \"spearman\", \"pearson\" and \"cosine\". Returns: PearsonResult | SpearmanrResult | float: correlation/similarity metric \"\"\" # Define the allowable metrics scipy_corrs = { \"pearson\" : pearsonr , \"spearman\" : spearmanr } if metric in scipy_corrs : return scipy_corrs [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" : return cosine_similarity ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) def compute_distance_metric ( self , ele1 : str , ele2 : str , metric : str = \"euclidean\" ) -> float : \"\"\" Compute distance metric between two vectors. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy * cosine (cosine distance) Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a distance metric Returns: distance (float): distance between embedding vectors \"\"\" # Define the allowable metrics scikit_metrics = [ \"euclidean\" , \"manhattan\" , \"chebyshev\" ] scipy_metrics = { \"wasserstein\" : wasserstein_distance , \"energy\" : energy_distance } valid_metrics = scikit_metrics + list ( scipy_metrics . keys ()) + [ \"cosine\" ] # Validate if the elements are within the embedding vector if not all ([ self . _is_el_in_embedding ( ele1 ), self . _is_el_in_embedding ( ele2 )]): if not self . _is_el_in_embedding ( ele1 ): print ( f \" { ele1 } is not an element included within the atomic embeddings\" ) raise ValueError elif not self . _is_el_in_embedding ( ele2 ): print ( f \" { ele2 } is not an element included within the atomic embeddings\" ) raise ValueError # Compute the distance measure if metric in scikit_metrics : distance = DistanceMetric . get_metric ( metric ) return distance . pairwise ( self . embeddings [ ele1 ] . reshape ( 1 , - 1 ), self . embeddings [ ele2 ] . reshape ( 1 , - 1 ), )[ 0 ][ 0 ] elif metric in scipy_metrics . keys (): return scipy_metrics [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" or metric == \"cosine_distance\" : return cosine_distance ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) else : print ( \"Invalid distance metric.\" f \"Use one of the following metrics: { valid_metrics } \" ) raise ValueError def pearson_pivot_table ( self ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) corr_df = self . correlation_df () pearson_pivot = corr_df . pivot_table ( values = \"pearson_corr\" , index = \"mend_1\" , columns = \"mend_2\" ) return pearson_pivot def distance_correlation_df ( self , metric : str = \"euclidean\" ) -> pd . DataFrame : \"\"\" Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy Args: metric (str): A distance metric. Returns: df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric]. \"\"\" ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : dist = self . compute_distance_metric ( ele1 , ele2 , metric = metric ) table . append (( ele1 , ele2 , dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , metric ]) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] Z_1 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_1\" ]] Z_2 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df [ \"Z_1\" ] = Z_1 corr_df [ \"Z_2\" ] = Z_2 corr_df = corr_df [[ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"Z_1\" , \"Z_2\" , metric ]] return corr_df def distance_pivot_table ( self , metric : str = \"euclidean\" , sortby : str = \"mendeleev\" ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Args: metric (str): A distance metric. sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\". Returns: distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table. \"\"\" corr_df = self . distance_correlation_df ( metric = metric ) if sortby == \"mendeleev\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"mend_1\" , columns = \"mend_2\" ) return distance_pivot elif sortby == \"atomic_number\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"Z_1\" , columns = \"Z_2\" ) return distance_pivot def plot_pearson_correlation ( self , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pearson correlation values. Args: figsize (tuple): A tuple of (width, height). **kwargs: Other keyword arguments to be passed to sns.heatmap Returns: ax (matplotlib Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) pearson_pivot = self . pearson_pivot_table () plt . figure ( figsize = figsize ) ax = sns . heatmap ( pearson_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax def plot_distance_correlation ( self , metric : str = \"euclidean\" , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pairwise distance metrics. Args: metric (str): A valid distance metric figsize (tuple): A tuple of (width, height) Returns: ax (matplotlib.axes.Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) distance_pivot = self . distance_pivot_table ( metric = metric ) plt . figure ( figsize = figsize ) ax = sns . heatmap ( distance_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax def calculate ( self , mode : str = \"all\" ) -> None : \"\"\" Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Args: mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"` will calculate all available distance and correlation metrics; `mode=\"correlation\"` will only calculate correlation metrics and `mode=\"distance\"` will only calculate distance metrics. Returns: None \"\"\" ele_pairs = self . create_pairs () table = [] # columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"] for ele1 , ele2 in ele_pairs : temp_dict = { \"element_1\" : ele1 , \"element_2\" : ele2 } table . append ( temp_dict ) pass def calculate_PC ( self , n_components : int , ** kwargs ): \"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\" pass def calculate_tSNE ( self , ** kwargs ): \"\"\"Calculate t-SNE components.\"\"\" pass def calculate_UMAP ( self , ** kwargs ): \"\"\"Calculate UMAP embeddings.\"\"\" pass def plot_PCA_2D ( self , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a PCA plot of the atomic embedding. Args: figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) pca = decomposition . PCA ( n_components = 2 ) # project to 2 dimensions pca . fit ( embeddings_array ) X = pca . transform ( embeddings_array ) pca_dim1 = X [:, 0 ] pca_dim2 = X [:, 1 ] # Create a dataframe to store the dimensions, labels and group info for the PCA pca_df = pd . DataFrame ( { \"pca_dim1\" : pca_dim1 , \"pca_dim2\" : pca_dim2 , \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"pca_dim1\" , y = \"pca_dim2\" , data = pca_df , hue = points_hue , s = points_size , ** kwargs , ax = ax , ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) for i in range ( len ( X )): plt . text ( x = pca_dim1 [ i ], y = pca_dim2 [ i ], s = element_array [ i ]) return plt def plot_tSNE ( self , n_components : str = 2 , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a t-SNE plot of the atomic embedding. Args: n_components (int): Number of t-SNE components to plot. figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) tsne = TSNE ( n_components ) tsne_result = tsne . fit_transform ( embeddings_array ) tsne_df = pd . DataFrame ( { \"tsne_dim1\" : tsne_result [:, 0 ], \"tsne_dim2\" : tsne_result [:, 1 ], \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) # Create the t-SNE plot fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"tsne_dim1\" , y = \"tsne_dim2\" , data = tsne_df , hue = points_hue , s = points_size , ax = ax , ) # lim = (tsne_result.min()-5, tsne_result.max()+5) # ax.set_xlim(lim) # ax.set_ylim(lim) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) # Label the points for i in range ( tsne_df . shape [ 0 ]): plt . text ( x = tsne_df [ \"tsne_dim1\" ][ i ], y = tsne_df [ \"tsne_dim2\" ][ i ], s = tsne_df [ \"element\" ][ i ], ) return plt","title":"Embedding"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.__init__","text":"Initialise the Embedding class. Parameters: Name Type Description Default embeddings dict A {element_symbol: vector} dictionary required embedding_name str The name of the elemental representation None Source code in AtomicEmbeddings/core.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , embeddings : dict , embedding_name : Optional [ str ] = None ): \"\"\"Initialise the Embedding class. Args: embeddings (dict): A {element_symbol: vector} dictionary embedding_name (str): The name of the elemental representation \"\"\" self . embeddings = embeddings self . embedding_name = embedding_name # Grab a random value from the embedding vector _rand_embed = random . choice ( list ( self . embeddings . values ())) # Convert embeddings to numpy array if not already a numpy array if not isinstance ( _rand_embed , np . ndarray ): self . embeddings = { ele : np . array ( self . embeddings [ ele ]) for ele in self . embeddings } # Determines if the embedding vector has a length attribute # (i.e. is not a scalar int or float) # If the 'vector' is a scalar/float, the representation is linear (dim=1) if hasattr ( _rand_embed , \"__len__\" ) and ( not isinstance ( _rand_embed , str )): self . dim : int = len ( random . choice ( list ( self . embeddings . values ()))) else : self . dim : int = int ( 1 ) # Dummy initialisation for results self . _data = []","title":"__init__()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.as_dataframe","text":"Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Parameters: Name Type Description Default columns str A string to specify if the columns are the vector components 'components' Returns: Name Type Description df pandas . DataFrame A pandas dataframe object Source code in AtomicEmbeddings/core.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def as_dataframe ( self , columns : str = \"components\" ) -> pd . DataFrame : \"\"\" Return the embedding as a pandas Dataframe. The first column is the elements and each other column represents a component of the embedding. Args: columns (str): A string to specify if the columns are the vector components and the index is the elements (`columns='components') or the columns are the elements (`columns='elements'`). Returns: df (pandas.DataFrame): A pandas dataframe object \"\"\" embedding = self . embeddings df = pd . DataFrame ( embedding ) if columns == \"components\" : return df . T elif columns == \"elements\" : return df else : raise ( ValueError ( f \" { columns } is not a valid keyword argument. \" \"Choose either 'components' or 'elements\" ) )","title":"as_dataframe()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate","text":"Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Parameters: Name Type Description Default mode str Specifies which pairwise statistics to calculate. mode=\"all\" will calculate all available distance and correlation metrics; mode=\"correlation\" will only calculate correlation metrics and mode=\"distance\" will only calculate distance metrics. 'all' Returns: Type Description None None Source code in AtomicEmbeddings/core.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def calculate ( self , mode : str = \"all\" ) -> None : \"\"\" Calculate the pairwise statistics of the elements present. The pairwise statistics include the distance and correlation metrics Args: mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"` will calculate all available distance and correlation metrics; `mode=\"correlation\"` will only calculate correlation metrics and `mode=\"distance\"` will only calculate distance metrics. Returns: None \"\"\" ele_pairs = self . create_pairs () table = [] # columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"] for ele1 , ele2 in ele_pairs : temp_dict = { \"element_1\" : ele1 , \"element_2\" : ele2 } table . append ( temp_dict ) pass","title":"calculate()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_PC","text":"Calculate the principal componenets (PC) of the embeddings. Source code in AtomicEmbeddings/core.py 741 742 743 def calculate_PC ( self , n_components : int , ** kwargs ): \"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\" pass","title":"calculate_PC()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_UMAP","text":"Calculate UMAP embeddings. Source code in AtomicEmbeddings/core.py 749 750 751 def calculate_UMAP ( self , ** kwargs ): \"\"\"Calculate UMAP embeddings.\"\"\" pass","title":"calculate_UMAP()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_tSNE","text":"Calculate t-SNE components. Source code in AtomicEmbeddings/core.py 745 746 747 def calculate_tSNE ( self , ** kwargs ): \"\"\"Calculate t-SNE components.\"\"\" pass","title":"calculate_tSNE()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.citation","text":"Return a citation for the embedding. Source code in AtomicEmbeddings/core.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def citation ( self ) -> List [ str ]: \"\"\"Return a citation for the embedding.\"\"\" if self . embedding_name in [ \"magpie\" , \"magpie_sc\" ]: citation = [ \"@article{ward2016general,\" \"title={A general-purpose machine learning framework for \" \"predicting properties of inorganic materials},\" \"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \" \"and Wolverton, Christopher},\" \"journal={npj Computational Materials},\" \"volume= {2} ,\" \"number= {1} ,\" \"pages={1--7},\" \"year= {2016} ,\" \"publisher={Nature Publishing Group}}\" ] elif self . embedding_name == \"mat2vec\" : citation = [ \"@article{tshitoyan2019unsupervised,\" \"title={Unsupervised word embeddings capture latent knowledge \" \"from materials science literature},\" \"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \" \"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \" \"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\" \"journal= {Nature} ,\" \"volume= {571} ,\" \"number= {7763} ,\" \"pages={95--98},\" \"year= {2019} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"matscholar\" : citation = [ \"@article{weston2019named,\" \"title={Named entity recognition and normalization applied to \" \"large-scale information extraction from the materials \" \"science literature},\" \"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \" \"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \" \"Ceder, Gerbrand and Jain, Anubhav},\" \"journal={Journal of chemical information and modeling},\" \"volume= {59} ,\" \"number= {9} ,\" \"pages={3692--3702},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"megnet16\" : citation = [ \"@article{chen2019graph,\" \"title={Graph networks as a universal machine learning framework \" \"for molecules and crystals},\" \"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \" \"Zheng, Chen and Ong, Shyue Ping},\" \"journal={Chemistry of Materials},\" \"volume= {31} ,\" \"number= {9} ,\" \"pages={3564--3572},\" \"year= {2019} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name in [ \"oliynyk\" , \"oliynyk_sc\" ]: citation = [ \" @article{oliynyk2016high,\" \"title={High-throughput machine-learning-driven synthesis \" \"of full-Heusler compounds},\" \"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \" \"Ghadbeigi, Leila and Gaultois, Michael W and \" \"Meredig, Bryce and Mar, Arthur},\" \"journal={Chemistry of Materials},\" \"volume= {28} ,\" \"number= {20} ,\" \"pages={7324--7331},\" \"year= {2016} ,\" \"publisher={ACS Publications} }\" ] elif self . embedding_name == \"skipatom\" : citation = [ \"@article{antunes2022distributed,\" \"title={Distributed representations of atoms and materials \" \"for machine learning},\" \"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\" \"journal={npj Computational Materials},\" \"volume= {8} ,\" \"number= {1} ,\" \"pages={1--9},\" \"year= {2022} ,\" \"publisher={Nature Publishing Group} }\" ] elif self . embedding_name == \"mod_petti\" : citation = [ \"@article{glawe2016optimal,\" \"title={The optimal one dimensional periodic table: \" \"a modified Pettifor chemical scale from data mining},\" \"author={Glawe, Henning and Sanna, Antonio and Gross, \" \"EKU and Marques, Miguel AL},\" \"journal={New Journal of Physics},\" \"volume= {18} ,\" \"number= {9} ,\" \"pages= {093011} ,\" \"year= {2016} ,\" \"publisher={IOP Publishing} }\" ] else : citation = [] return citation","title":"citation()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.compute_correlation_metric","text":"Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Parameters: Name Type Description Default ele1 str element symbol required ele2 str element symbol required metric str name of a correlation metric. 'pearson' Returns: Type Description Union [ PearsonRResult , SpearmanrResult , float ] PearsonResult | SpearmanrResult | float: correlation/similarity metric Source code in AtomicEmbeddings/core.py 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def compute_correlation_metric ( self , ele1 : str , ele2 : str , metric : str = \"pearson\" ) -> Union [ PearsonRResult , SpearmanrResult , float ]: \"\"\" Compute the correlation/similarity metric between two vectors. Allowed metrics: * Pearson * Spearman * Cosine similarity Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a correlation metric. Options are \"spearman\", \"pearson\" and \"cosine\". Returns: PearsonResult | SpearmanrResult | float: correlation/similarity metric \"\"\" # Define the allowable metrics scipy_corrs = { \"pearson\" : pearsonr , \"spearman\" : spearmanr } if metric in scipy_corrs : return scipy_corrs [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" : return cosine_similarity ( self . embeddings [ ele1 ], self . embeddings [ ele2 ])","title":"compute_correlation_metric()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.compute_distance_metric","text":"Compute distance metric between two vectors. Allowed metrics: euclidean manhattan chebyshev wasserstein energy cosine (cosine distance) Parameters: Name Type Description Default ele1 str element symbol required ele2 str element symbol required metric str name of a distance metric 'euclidean' Returns: Name Type Description distance float distance between embedding vectors Source code in AtomicEmbeddings/core.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 def compute_distance_metric ( self , ele1 : str , ele2 : str , metric : str = \"euclidean\" ) -> float : \"\"\" Compute distance metric between two vectors. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy * cosine (cosine distance) Args: ele1 (str): element symbol ele2 (str): element symbol metric (str): name of a distance metric Returns: distance (float): distance between embedding vectors \"\"\" # Define the allowable metrics scikit_metrics = [ \"euclidean\" , \"manhattan\" , \"chebyshev\" ] scipy_metrics = { \"wasserstein\" : wasserstein_distance , \"energy\" : energy_distance } valid_metrics = scikit_metrics + list ( scipy_metrics . keys ()) + [ \"cosine\" ] # Validate if the elements are within the embedding vector if not all ([ self . _is_el_in_embedding ( ele1 ), self . _is_el_in_embedding ( ele2 )]): if not self . _is_el_in_embedding ( ele1 ): print ( f \" { ele1 } is not an element included within the atomic embeddings\" ) raise ValueError elif not self . _is_el_in_embedding ( ele2 ): print ( f \" { ele2 } is not an element included within the atomic embeddings\" ) raise ValueError # Compute the distance measure if metric in scikit_metrics : distance = DistanceMetric . get_metric ( metric ) return distance . pairwise ( self . embeddings [ ele1 ] . reshape ( 1 , - 1 ), self . embeddings [ ele2 ] . reshape ( 1 , - 1 ), )[ 0 ][ 0 ] elif metric in scipy_metrics . keys (): return scipy_metrics [ metric ]( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) elif metric == \"cosine\" or metric == \"cosine_distance\" : return cosine_distance ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) else : print ( \"Invalid distance metric.\" f \"Use one of the following metrics: { valid_metrics } \" ) raise ValueError","title":"compute_distance_metric()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.correlation_df","text":"Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. Source code in AtomicEmbeddings/core.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def correlation_df ( self ) -> pd . DataFrame : \"\"\"Return a pandas.DataFrame with correlation metrics. The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist]. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : pearson = pearsonr ( self . embeddings [ ele1 ], self . embeddings [ ele2 ]) dist = norm ( self . embeddings [ ele1 ] - self . embeddings [ ele2 ]) table . append (( ele1 , ele2 , pearson [ 0 ], dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , pearson [ 0 ], dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , \"pearson_corr\" , \"euclid_dist\" , ], ) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df = corr_df [ [ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"euclid_dist\" , \"pearson_corr\" , ] ] return corr_df","title":"correlation_df()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.create_pairs","text":"Create all possible pairs of elements. Source code in AtomicEmbeddings/core.py 432 433 434 435 436 def create_pairs ( self ): \"\"\"Create all possible pairs of elements.\"\"\" ele_list = self . element_list ele_pairs = combinations_with_replacement ( ele_list , 2 ) return ele_pairs","title":"create_pairs()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.distance_correlation_df","text":"Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: euclidean manhattan chebyshev wasserstein energy Parameters: Name Type Description Default metric str A distance metric. 'euclidean' Returns: Name Type Description df pandas . DataFrame A dataframe with columns [\"ele_1\", \"ele_2\", metric]. Source code in AtomicEmbeddings/core.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 def distance_correlation_df ( self , metric : str = \"euclidean\" ) -> pd . DataFrame : \"\"\" Return a dataframe with columns [\"ele_1\", \"ele_2\", metric]. Allowed metrics: * euclidean * manhattan * chebyshev * wasserstein * energy Args: metric (str): A distance metric. Returns: df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric]. \"\"\" ele_pairs = self . create_pairs () table = [] for ele1 , ele2 in ele_pairs : dist = self . compute_distance_metric ( ele1 , ele2 , metric = metric ) table . append (( ele1 , ele2 , dist )) if ele1 != ele2 : table . append (( ele2 , ele1 , dist )) corr_df = pd . DataFrame ( table , columns = [ \"ele_1\" , \"ele_2\" , metric ]) mend_1 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_1\" ]] mend_2 = [( Element ( ele ) . mendeleev_no , ele ) for ele in corr_df [ \"ele_2\" ]] Z_1 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_1\" ]] Z_2 = [( pt [ ele ][ \"number\" ], ele ) for ele in corr_df [ \"ele_2\" ]] corr_df [ \"mend_1\" ] = mend_1 corr_df [ \"mend_2\" ] = mend_2 corr_df [ \"Z_1\" ] = Z_1 corr_df [ \"Z_2\" ] = Z_2 corr_df = corr_df [[ \"ele_1\" , \"ele_2\" , \"mend_1\" , \"mend_2\" , \"Z_1\" , \"Z_2\" , metric ]] return corr_df","title":"distance_correlation_df()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.distance_pivot_table","text":"Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Parameters: Name Type Description Default metric str A distance metric. 'euclidean' sortby str Sort the pivot table by either \"mendeleev\" or \"atomic_number\". 'mendeleev' Returns: Name Type Description distance_pivot pandas . DataFrame A pandas DataFrame pivot table. Source code in AtomicEmbeddings/core.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 def distance_pivot_table ( self , metric : str = \"euclidean\" , sortby : str = \"mendeleev\" ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot. The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric. Args: metric (str): A distance metric. sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\". Returns: distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table. \"\"\" corr_df = self . distance_correlation_df ( metric = metric ) if sortby == \"mendeleev\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"mend_1\" , columns = \"mend_2\" ) return distance_pivot elif sortby == \"atomic_number\" : distance_pivot = corr_df . pivot_table ( values = metric , index = \"Z_1\" , columns = \"Z_2\" ) return distance_pivot","title":"distance_pivot_table()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.element_groups_dict","text":"Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} Source code in AtomicEmbeddings/core.py 420 421 422 423 424 425 426 427 428 429 430 @property def element_groups_dict ( self ) -> Dict [ str , str ]: \"\"\" Return a dictionary of {element: element type} pairs. e.g. {'He':'Noble gas'} \"\"\" with open ( path . join ( data_directory , \"element_data/element_group.json\" )) as f : _dict = json . load ( f ) return { i : _dict [ i ] for i in self . element_list }","title":"element_groups_dict()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.element_list","text":"Return the elements of the embedding. Source code in AtomicEmbeddings/core.py 261 262 263 264 @property def element_list ( self ) -> list : \"\"\"Return the elements of the embedding.\"\"\" return list ( self . embeddings . keys ())","title":"element_list()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.from_csv","text":"Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Parameters: Name Type Description Default embedding_csv str Filepath of the csv file required Source code in AtomicEmbeddings/core.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @staticmethod def from_csv ( embedding_csv ): \"\"\" Create an instance of the Embedding class from a csv file. The first column of the csv file must contain the elements and be named element. Args: embedding_csv (str): Filepath of the csv file \"\"\" # Need to add validation handling for csv files df = pd . read_csv ( embedding_csv ) elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } return Embedding ( embedding_data )","title":"from_csv()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.from_json","text":"Create an instance of the Embedding class from a json file. Parameters: Name Type Description Default embedding_json str Filepath of the json file required Source code in AtomicEmbeddings/core.py 164 165 166 167 168 169 170 171 172 173 174 175 @staticmethod def from_json ( embedding_json ): \"\"\" Create an instance of the Embedding class from a json file. Args: embedding_json (str): Filepath of the json file \"\"\" # Need to add validation handling for JSONs in different formats with open ( embedding_json ) as f : embedding_data = json . load ( f ) return Embedding ( embedding_data )","title":"from_json()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.load_data","text":"Create an instance of the Embedding class from a default embedding file. The default embeddings are in the table below: Name str_name Magpie magpie Magpie (scaled) magpie_sc Mat2Vec mat2vec Matscholar matscholar Megnet (16 dimensions) megnet16 Modified pettifor scale mod_petti Oliynyk oliynyk Oliynyk (scaled) oliynyk_sc Random (200 dimensions) random_200 SkipAtom skipatom Parameters: Name Type Description Default embedding_name str The str_name of an embedding file. None Returns: Name Type Description Embedding class: Embedding instance. Source code in AtomicEmbeddings/core.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @staticmethod def load_data ( embedding_name : Optional [ str ] = None ): \"\"\" Create an instance of the `Embedding` class from a default embedding file. The default embeddings are in the table below: | **Name** | **str_name** | |-------------------------|--------------| | Magpie | magpie | | Magpie (scaled) | magpie_sc | | Mat2Vec | mat2vec | | Matscholar | matscholar | | Megnet (16 dimensions) | megnet16 | | Modified pettifor scale | mod_petti | | Oliynyk | oliynyk | | Oliynyk (scaled) | oliynyk_sc | | Random (200 dimensions) | random_200 | | SkipAtom | skipatom | Args: embedding_name (str): The str_name of an embedding file. Returns: Embedding :class:`Embedding` instance. \"\"\" _cbfv_files = { \"magpie\" : \"magpie.csv\" , \"magpie_sc\" : \"magpie_sc.json\" , \"mat2vec\" : \"mat2vec.csv\" , \"matscholar\" : \"matscholar-embedding.json\" , \"megnet16\" : \"megnet16.json\" , \"mod_petti\" : \"mod_petti.json\" , \"oliynyk\" : \"oliynyk.json\" , \"oliynyk_sc\" : \"oliynyk_sc.json\" , \"random_200\" : \"random_200_new.csv\" , \"skipatom\" : \"skipatom_20201009_induced.csv\" , } _cbfv_names = list ( _cbfv_files . keys ()) _cbfv_names_others = [ i for i in _cbfv_names if i not in [ \"skipatom\" , \"random_200\" , \"megnet16\" , \"magpie\" , \"mat2vec\" ] ] # Get the embeddings if embedding_name in _cbfv_files : if embedding_name in [ \"skipatom\" , \"random_200\" , \"magpie\" , \"mat2vec\" ]: _csv = path . join ( data_directory , _cbfv_files [ embedding_name ]) df = pd . read_csv ( _csv ) # Convert df to a dictionary of (ele:embeddings) pairs elements = list ( df [ \"element\" ]) df . drop ([ \"element\" ], axis = 1 , inplace = True ) embeds_array = df . to_numpy () embedding_data = { elements [ i ]: embeds_array [ i ] for i in range ( len ( embeds_array )) } elif embedding_name == \"megnet16\" : megnet16_json = path . join ( data_directory , _cbfv_files [ \"megnet16\" ]) with open ( megnet16_json ) as f : embedding_data = json . load ( f ) # Remove 'Null' key from megnet embedding del embedding_data [ \"Null\" ] elif embedding_name in _cbfv_names_others : _json = path . join ( data_directory , _cbfv_files [ embedding_name ]) with open ( _json ) as f : embedding_data = json . load ( f ) # Load a json file from a file specified in the input else : with open ( embedding_name ) as f : embedding_data = json . load ( f ) else : raise ( ValueError ( f \" { embedding_name } not in the data directory or not in directory.\" ) ) return Embedding ( embedding_data , embedding_name )","title":"load_data()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.pearson_pivot_table","text":"Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. Source code in AtomicEmbeddings/core.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def pearson_pivot_table ( self ) -> pd . DataFrame : \"\"\" Return a pandas.DataFrame style pivot object. The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics. \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) corr_df = self . correlation_df () pearson_pivot = corr_df . pivot_table ( values = \"pearson_corr\" , index = \"mend_1\" , columns = \"mend_2\" ) return pearson_pivot","title":"pearson_pivot_table()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_PCA_2D","text":"Plot a PCA plot of the atomic embedding. Parameters: Name Type Description Default figsize tuple A tuple of (width, height) (16, 12) points_size float The marker size 200 Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the PCA plot Source code in AtomicEmbeddings/core.py 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 def plot_PCA_2D ( self , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a PCA plot of the atomic embedding. Args: figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) pca = decomposition . PCA ( n_components = 2 ) # project to 2 dimensions pca . fit ( embeddings_array ) X = pca . transform ( embeddings_array ) pca_dim1 = X [:, 0 ] pca_dim2 = X [:, 1 ] # Create a dataframe to store the dimensions, labels and group info for the PCA pca_df = pd . DataFrame ( { \"pca_dim1\" : pca_dim1 , \"pca_dim2\" : pca_dim2 , \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"pca_dim1\" , y = \"pca_dim2\" , data = pca_df , hue = points_hue , s = points_size , ** kwargs , ax = ax , ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) for i in range ( len ( X )): plt . text ( x = pca_dim1 [ i ], y = pca_dim2 [ i ], s = element_array [ i ]) return plt","title":"plot_PCA_2D()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_distance_correlation","text":"Plot the heatmap of the pairwise distance metrics. Parameters: Name Type Description Default metric str A valid distance metric 'euclidean' figsize tuple A tuple of (width, height) (24, 24) Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the heatmap Source code in AtomicEmbeddings/core.py 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 def plot_distance_correlation ( self , metric : str = \"euclidean\" , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pairwise distance metrics. Args: metric (str): A valid distance metric figsize (tuple): A tuple of (width, height) Returns: ax (matplotlib.axes.Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) distance_pivot = self . distance_pivot_table ( metric = metric ) plt . figure ( figsize = figsize ) ax = sns . heatmap ( distance_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax","title":"plot_distance_correlation()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_pearson_correlation","text":"Plot the heatmap of the pearson correlation values. Parameters: Name Type Description Default figsize tuple A tuple of (width, height). (24, 24) **kwargs Other keyword arguments to be passed to sns.heatmap {} Returns: Name Type Description ax matplotlib Axes An Axes object with the heatmap Source code in AtomicEmbeddings/core.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 def plot_pearson_correlation ( self , figsize : Tuple [ int , int ] = ( 24 , 24 ), ** kwargs ): \"\"\" Plot the heatmap of the pearson correlation values. Args: figsize (tuple): A tuple of (width, height). **kwargs: Other keyword arguments to be passed to sns.heatmap Returns: ax (matplotlib Axes): An Axes object with the heatmap \"\"\" warnings . warn ( \"This method is deprecated and will be removed in a future release. \" , DeprecationWarning , ) pearson_pivot = self . pearson_pivot_table () plt . figure ( figsize = figsize ) ax = sns . heatmap ( pearson_pivot , cmap = \"bwr\" , square = True , linecolor = \"k\" , ** kwargs ) return ax","title":"plot_pearson_correlation()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_tSNE","text":"Plot a t-SNE plot of the atomic embedding. Parameters: Name Type Description Default n_components int Number of t-SNE components to plot. 2 figsize tuple A tuple of (width, height) (16, 12) points_size float The marker size 200 Returns: Name Type Description ax matplotlib . axes . Axes An Axes object with the PCA plot Source code in AtomicEmbeddings/core.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 def plot_tSNE ( self , n_components : str = 2 , figsize : Tuple [ int , int ] = ( 16 , 12 ), points_hue : str = \"group\" , points_size : int = 200 , ** kwargs , ): \"\"\"Plot a t-SNE plot of the atomic embedding. Args: n_components (int): Number of t-SNE components to plot. figsize (tuple): A tuple of (width, height) points_size (float): The marker size Returns: ax (matplotlib.axes.Axes): An Axes object with the PCA plot \"\"\" embeddings_array = np . array ( list ( self . embeddings . values ())) element_array = np . array ( self . element_list ) tsne = TSNE ( n_components ) tsne_result = tsne . fit_transform ( embeddings_array ) tsne_df = pd . DataFrame ( { \"tsne_dim1\" : tsne_result [:, 0 ], \"tsne_dim2\" : tsne_result [:, 1 ], \"element\" : element_array , \"group\" : list ( self . element_groups_dict . values ()), } ) # Create the t-SNE plot fig , ax = plt . subplots ( figsize = figsize ) sns . scatterplot ( x = \"tsne_dim1\" , y = \"tsne_dim2\" , data = tsne_df , hue = points_hue , s = points_size , ax = ax , ) # lim = (tsne_result.min()-5, tsne_result.max()+5) # ax.set_xlim(lim) # ax.set_ylim(lim) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) # Label the points for i in range ( tsne_df . shape [ 0 ]): plt . text ( x = tsne_df [ \"tsne_dim1\" ][ i ], y = tsne_df [ \"tsne_dim2\" ][ i ], s = tsne_df [ \"element\" ][ i ], ) return plt","title":"plot_tSNE()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.remove_elements","text":"Remove elements from the Embedding instance. Parameters: Name Type Description Default elements str,list(str An element symbol or a list of element symbols required inplace bool If True, elements are removed from the Embedding instance. False Source code in AtomicEmbeddings/core.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def remove_elements ( self , elements : Union [ str , List [ str ]], inplace : bool = False ): # TO-DO allow removal by atomic numbers \"\"\" Remove elements from the Embedding instance. Args: elements (str,list(str)): An element symbol or a list of element symbols inplace (bool): If True, elements are removed from the Embedding instance. If false, the original embedding instance is unchanged and a new embedding instance with the elements removed is created. \"\"\" if inplace : if isinstance ( elements , str ): del self . embeddings [ elements ] elif isinstance ( elements , list ): for el in elements : del self . embeddings [ el ] return None else : embeddings_copy = self . embeddings . copy () if isinstance ( elements , str ): del embeddings_copy [ elements ] elif isinstance ( elements , list ): for el in elements : del embeddings_copy [ el ] return Embedding ( embeddings_copy , self . embedding_name )","title":"remove_elements()"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.to","text":"Output the embedding to a file. Parameters: Name Type Description Default fmt str The file format to output the embedding to. '' filename str The name of the file to be outputted '' Returns: Type Description (str) if filename not specified, otherwise None. Source code in AtomicEmbeddings/core.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def to ( self , fmt : str = \"\" , filename : Optional [ str ] = \"\" ): \"\"\" Output the embedding to a file. Args: fmt (str): The file format to output the embedding to. Options include \"json\" and \"csv\". filename (str): The name of the file to be outputted Returns: (str) if filename not specified, otherwise None. \"\"\" fmt = fmt . lower () if fmt == \"json\" or fnmatch . fnmatch ( filename , \"*.json\" ): j = json . dumps ( self . embeddings , cls = NumpyEncoder ) if filename : if not filename . endswith ( \".json\" ): filename = filename + \".json\" with open ( filename , \"w\" ) as file : file . write ( j ) else : return j elif fmt == \"csv\" or fnmatch . fnmatch ( filename , \"*.csv\" ): if filename : if not filename . endswith ( \".csv\" ): filename = filename + \".csv\" self . as_dataframe () . to_csv ( filename , index_label = \"element\" ) else : return self . as_dataframe () . to_csv ( index_label = \"element\" ) else : raise ValueError ( f \" { str ( fmt ) } is an invalid file format\" )","title":"to()"},{"location":"python_api/plotter/","text":"Provides the plotting functions for visualising Embeddings. heatmap_plotter ( embedding , metric , distance = True , correlation = False , figsize = ( 36 , 24 ), filename = None , show = True , ** kwargs ) Plot a heatmap of the embedding. Parameters Embedding The embedding to be plotted. str The distance/correlation metric to be used. bool, optional Whether to plot a distance heatmap, by default True bool, optional Whether to plot a correlation heatmap, by default False Tuple[int,int], optional The size of the figure, by default (36, 24) Optional[str], optional The filename to save the figure to, by default None bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap Source code in AtomicEmbeddings/plotter.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def heatmap_plotter ( embedding : Embedding , metric : str , distance : bool = True , correlation : bool = False , figsize : Tuple [ int , int ] = ( 36 , 24 ), filename : Optional [ str ] = None , show : bool = True , ** kwargs , ): \"\"\" Plot a heatmap of the embedding. Parameters ---------- embedding : Embedding The embedding to be plotted. metric : str The distance/correlation metric to be used. distance : bool, optional Whether to plot a distance heatmap, by default True correlation : bool, optional Whether to plot a correlation heatmap, by default False figsize : Tuple[int,int], optional The size of the figure, by default (36, 24) filename : Optional[str], optional The filename to save the figure to, by default None show : bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap \"\"\" fig , ax = plt . subplots ( figsize = figsize ) if correlation : pivot = embedding . pearson_pivot_table () elif distance : pivot = embedding . distance_pivot_table ( metric = metric ) xlabels = [ i [ 1 ] for i in pivot . index ] ylabels = [ i [ 1 ] for i in pivot . columns ] sns . heatmap ( pivot , cmap = \"bwr\" , square = \"True\" , linecolor = \"k\" , ax = ax , cbar_kws = { \"shrink\" : 0.5 }, xticklabels = True , yticklabels = True , ** kwargs , ) ax . title . set_text ( embedding . embedding_name ) ax . set_xticklabels ( xlabels , ) ax . set_yticklabels ( ylabels ) ax . set_xlabel ( \"\" ) ax . set_ylabel ( \"\" ) fig . tight_layout () if filename : plt . savefig ( filename ) if show : plt . show () multi_heatmap_plotter ( embeddings , nrows , ncols , metric , sortaxisby = 'mendeleev' , figsize = ( 36 , 36 ), filename = None , show_axislabels = True , show_plot = True , ** kwargs ) Plot multiple heatmaps of the embeddings. Parameters List[Embedding] The embeddings to be plotted. int The number of rows in the figure. int The number of columns in the figure. bool, optional Whether to plot a metric distance heatmap, by default False str, optional The attribute to sort the axis by, by default \"mendeleev_number\". Options are \"mendeleev_number\", \"atomic_number\" Tuple[int,int], optional The size of the figure, by default (36, 36) Optional[str], optional The filename to save the figure to, by default None bool, optional Whether to show the axis, by default True bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap Source code in AtomicEmbeddings/plotter.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def multi_heatmap_plotter ( embeddings : List [ Embedding ], nrows : int , ncols : int , metric : str , sortaxisby : str = \"mendeleev\" , figsize : Tuple [ int , int ] = ( 36 , 36 ), filename : Optional [ str ] = None , show_axislabels : bool = True , show_plot : bool = True , ** kwargs , ): \"\"\" Plot multiple heatmaps of the embeddings. Parameters ---------- embeddings : List[Embedding] The embeddings to be plotted. nrows : int The number of rows in the figure. ncols : int The number of columns in the figure. metric : bool, optional Whether to plot a metric distance heatmap, by default False sortaxisby : str, optional The attribute to sort the axis by, by default \"mendeleev_number\". Options are \"mendeleev_number\", \"atomic_number\" figsize : Tuple[int,int], optional The size of the figure, by default (36, 36) filename : Optional[str], optional The filename to save the figure to, by default None show_axislabels : bool, optional Whether to show the axis, by default True show_plot : bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap \"\"\" fig , axes = plt . subplots ( nrows = nrows , ncols = ncols , figsize = figsize ) for i , embedding in enumerate ( embeddings ): ax = axes [ i // ncols , i % ncols ] correlation_metrics = [ \"spearman\" , \"pearson\" , \"cosine_similarity\" ] distance_metrics = [ \"euclidean\" , \"manhattan\" , \"cosine_distance\" , \"chebyshev\" , \"wasserstein\" , \"energy\" , ] if metric in correlation_metrics : p = embedding . pearson_pivot_table () elif metric in distance_metrics : p = embedding . distance_pivot_table ( metric = metric , sortby = sortaxisby ) xlabels = [ i [ 1 ] for i in p . index ] ylabels = [ i [ 1 ] for i in p . columns ] sns . heatmap ( p , cmap = \"bwr\" , square = \"True\" , linecolor = \"k\" , ax = ax , cbar_kws = { \"shrink\" : 0.5 , }, xticklabels = True , yticklabels = True , ** kwargs , ) ax . set_title ( embedding . embedding_name , fontdict = { \"fontsize\" : 30 , \"fontweight\" : \"bold\" } ) if not show_axislabels : ax . set_xticklabels ([]) ax . set_yticklabels ([]) ax . set_xticks ([]) ax . set_yticks ([]) else : ax . set_xticklabels ( xlabels , ) ax . set_yticklabels ( ylabels ) ax . set_xlabel ( \"\" ) ax . set_ylabel ( \"\" ) fig . tight_layout () if filename : plt . savefig ( filename ) if show_plot : plt . show ()","title":"Plotter module"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.heatmap_plotter","text":"Plot a heatmap of the embedding.","title":"heatmap_plotter()"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.heatmap_plotter--parameters","text":"Embedding The embedding to be plotted. str The distance/correlation metric to be used. bool, optional Whether to plot a distance heatmap, by default True bool, optional Whether to plot a correlation heatmap, by default False Tuple[int,int], optional The size of the figure, by default (36, 24) Optional[str], optional The filename to save the figure to, by default None bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap Source code in AtomicEmbeddings/plotter.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def heatmap_plotter ( embedding : Embedding , metric : str , distance : bool = True , correlation : bool = False , figsize : Tuple [ int , int ] = ( 36 , 24 ), filename : Optional [ str ] = None , show : bool = True , ** kwargs , ): \"\"\" Plot a heatmap of the embedding. Parameters ---------- embedding : Embedding The embedding to be plotted. metric : str The distance/correlation metric to be used. distance : bool, optional Whether to plot a distance heatmap, by default True correlation : bool, optional Whether to plot a correlation heatmap, by default False figsize : Tuple[int,int], optional The size of the figure, by default (36, 24) filename : Optional[str], optional The filename to save the figure to, by default None show : bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap \"\"\" fig , ax = plt . subplots ( figsize = figsize ) if correlation : pivot = embedding . pearson_pivot_table () elif distance : pivot = embedding . distance_pivot_table ( metric = metric ) xlabels = [ i [ 1 ] for i in pivot . index ] ylabels = [ i [ 1 ] for i in pivot . columns ] sns . heatmap ( pivot , cmap = \"bwr\" , square = \"True\" , linecolor = \"k\" , ax = ax , cbar_kws = { \"shrink\" : 0.5 }, xticklabels = True , yticklabels = True , ** kwargs , ) ax . title . set_text ( embedding . embedding_name ) ax . set_xticklabels ( xlabels , ) ax . set_yticklabels ( ylabels ) ax . set_xlabel ( \"\" ) ax . set_ylabel ( \"\" ) fig . tight_layout () if filename : plt . savefig ( filename ) if show : plt . show ()","title":"Parameters"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.multi_heatmap_plotter","text":"Plot multiple heatmaps of the embeddings.","title":"multi_heatmap_plotter()"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.multi_heatmap_plotter--parameters","text":"List[Embedding] The embeddings to be plotted. int The number of rows in the figure. int The number of columns in the figure. bool, optional Whether to plot a metric distance heatmap, by default False str, optional The attribute to sort the axis by, by default \"mendeleev_number\". Options are \"mendeleev_number\", \"atomic_number\" Tuple[int,int], optional The size of the figure, by default (36, 36) Optional[str], optional The filename to save the figure to, by default None bool, optional Whether to show the axis, by default True bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap Source code in AtomicEmbeddings/plotter.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def multi_heatmap_plotter ( embeddings : List [ Embedding ], nrows : int , ncols : int , metric : str , sortaxisby : str = \"mendeleev\" , figsize : Tuple [ int , int ] = ( 36 , 36 ), filename : Optional [ str ] = None , show_axislabels : bool = True , show_plot : bool = True , ** kwargs , ): \"\"\" Plot multiple heatmaps of the embeddings. Parameters ---------- embeddings : List[Embedding] The embeddings to be plotted. nrows : int The number of rows in the figure. ncols : int The number of columns in the figure. metric : bool, optional Whether to plot a metric distance heatmap, by default False sortaxisby : str, optional The attribute to sort the axis by, by default \"mendeleev_number\". Options are \"mendeleev_number\", \"atomic_number\" figsize : Tuple[int,int], optional The size of the figure, by default (36, 36) filename : Optional[str], optional The filename to save the figure to, by default None show_axislabels : bool, optional Whether to show the axis, by default True show_plot : bool, optional Whether to show the figure, by default True **kwargs Additional keyword arguments to pass to seaborn.heatmap \"\"\" fig , axes = plt . subplots ( nrows = nrows , ncols = ncols , figsize = figsize ) for i , embedding in enumerate ( embeddings ): ax = axes [ i // ncols , i % ncols ] correlation_metrics = [ \"spearman\" , \"pearson\" , \"cosine_similarity\" ] distance_metrics = [ \"euclidean\" , \"manhattan\" , \"cosine_distance\" , \"chebyshev\" , \"wasserstein\" , \"energy\" , ] if metric in correlation_metrics : p = embedding . pearson_pivot_table () elif metric in distance_metrics : p = embedding . distance_pivot_table ( metric = metric , sortby = sortaxisby ) xlabels = [ i [ 1 ] for i in p . index ] ylabels = [ i [ 1 ] for i in p . columns ] sns . heatmap ( p , cmap = \"bwr\" , square = \"True\" , linecolor = \"k\" , ax = ax , cbar_kws = { \"shrink\" : 0.5 , }, xticklabels = True , yticklabels = True , ** kwargs , ) ax . set_title ( embedding . embedding_name , fontdict = { \"fontsize\" : 30 , \"fontweight\" : \"bold\" } ) if not show_axislabels : ax . set_xticklabels ([]) ax . set_yticklabels ([]) ax . set_xticks ([]) ax . set_yticks ([]) else : ax . set_xticklabels ( xlabels , ) ax . set_yticklabels ( ylabels ) ax . set_xlabel ( \"\" ) ax . set_ylabel ( \"\" ) fig . tight_layout () if filename : plt . savefig ( filename ) if show_plot : plt . show ()","title":"Parameters"},{"location":"python_api/python_api/","text":"Atomic Embeddings Python package The core module of the AtomicEmbeddings contains the Embedding class which is used to store and manipulate elemental representation data. This part of the project documentation provides the python API for the AtomicEmbeddings package. Core module Composition module Plotter module","title":"Atomic Embeddings Python package"},{"location":"python_api/python_api/#atomic-embeddings-python-package","text":"The core module of the AtomicEmbeddings contains the Embedding class which is used to store and manipulate elemental representation data. This part of the project documentation provides the python API for the AtomicEmbeddings package. Core module Composition module Plotter module","title":"Atomic Embeddings Python package"}]}