{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AtomicEmbeddings","text":"<p>This site contains the project documentation for the <code>AtomicEmbeddings</code> package which provides tools and examples of analysing and visualising elemental representation data.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<p>The documentation consists of the following six parts:</p> <ol> <li>About</li> <li>Getting Started</li> <li>Python API</li> <li>Tutorials</li> <li>Reference</li> <li>Contributing</li> </ol>"},{"location":"#project-overview","title":"Project Overview","text":"<p>Analyse elemental representation data.</p> <p>Modules exported by this package:</p> <ul> <li><code>AtomicEmbeddings.core</code>: Provides the <code>Embedding</code> class.</li> <li><code>AtomicEmbeddings.composition</code>: Tools to featurise compositions.</li> <li><code>AtomicEmbeddings.plotter</code>: Tools to plot embeddings.</li> </ul>"},{"location":"about/","title":"About the AtomicEmbeddings package","text":"<p>====</p> <p> </p> <p>The Atomic Embeddings package provides high-level tools for analysing elemental embeddings data. This primarily involves visualising the correlation between embedding schemes using different statistical measures.</p>"},{"location":"about/#motivation","title":"Motivation","text":"<p>Machine learning approaches for materials informatics have become increasingly widespread. Some of these involve the use of deep learning techniques where the representation of the elements is learned rather than specified by the user of the model. While an important goal of machine learning training is to minimise the chosen error function to make more accurate predictions, it is also important for us material scientists to be able to interpret these models. As such, we aim to evaluate and compare different atomic embedding schemes in a consistent framework.</p>"},{"location":"contribution/","title":"Contributing","text":""},{"location":"contribution/#bug-reports-feature-requests-and-questions","title":"Bug reports, feature requests and questions","text":"<p>Please use the Issue Tracker to report bugs or request features in the first instance. Contributions are always welcome. </p>"},{"location":"contribution/#code-contributions","title":"Code contributions","text":"<p>We are always looking for ways to make <code>AtomicEmbeddings</code> better and a more useful to a wider community. For making contributions, use the \"Fork and Pull\" workflow to make contributions and stick as closely as possible to the following:</p> <ul> <li>Code style should comply with PEP8 where possible. Google's house style is also helpful, including a good model for docstrings.</li> <li>Please use comments liberally when adding nontrivial features, and take the chance to clean up other people's code while looking at it.</li> <li>Add tests wherever possible, and use the test suite to check if you broke anything.</li> </ul>"},{"location":"installation/","title":"Getting Started","text":"<p>The latest version of the package can be installed using:</p> <pre><code>pip install git+git://github.com/WMD-group/Atomic_Embeddings.git\n</code></pre>"},{"location":"installation/#developers-installation-optional","title":"Developer's installation (optional)","text":"<p>For development work, <code>AtomicEmbeddings</code> can eb installed from a copy of the source repository; this is preferred if using experimental code branches.</p> <p>To clone the project from Github and make a local installation:</p> <p><pre><code>git clone https://github.com/WMD-group/Atomic_Embeddings.git\ncd Atomic_Embeddings\npip install --user -e .\n</code></pre> With <code>-e</code>, pip will create links to the source folder so that the changes to the code will be reflected on the PATH.</p>"},{"location":"reference/","title":"Elemental Embeddings","text":"<p>The data contained in this folder is a collection of various elemental representation/embedding schemes</p>"},{"location":"reference/#magpie","title":"Magpie","text":"<p>The following paper describes the details of the Materials Agnostic Platform for Informatics and Exploration (Magpie) framework: A general-purpose machine learning framework for predicting properties of inorganic materials</p> <p>The source code for Magpie can be found here</p> <p>The 22 dimensional embedding vector includes the following elemental properties:</p> Click to see the 22 properties  * Number; * Mendeleev number; * Atomic weight; * Melting temperature; * Group number; * Period; * Covalent Radius;  * Electronegativity; * no. of s, p, d, f  valence electrons (4 features); * no. of valence electrons; * no. of unfilled: s, p, d, f orbitals (4 features), * no. of unfilled orbtials * GSvolume_pa (DFT volume per atom of T=0K ground state from the OQMD) * GSbandgap(DFT bandgap energy of T=0K ground state from the OQMD) * GSmagmom (DFT magnetic moment of T=0K ground state from the OQMD) * Space Group Number  <ul> <li><code>magpie_sc</code> is scaled version of the magpie embeddings</li> </ul>"},{"location":"reference/#mat2vec","title":"mat2vec","text":"<p>The following paper describes the implementation of mat2vec: Unsupervised word embeddings capture latent knowledge from materials science literature</p>"},{"location":"reference/#matscholar","title":"MatScholar","text":"<p>The following paper describes the natural language processing implementation of Materials Scholar (matscholar): Named Entity Recognition and Normalization Applied to Large-Scale Information Extraction from the Materials Science Literature</p>"},{"location":"reference/#megnet","title":"MEGnet","text":"<p>The following paper describes the details of the construction of the MatErials Graph Network (MEGNet): Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals</p>"},{"location":"reference/#modified-pettifor-scale","title":"Modified Pettifor scale","text":"<p>The following paper describes the details of the modified Pettifor chemical scale: The optimal one dimensional periodic table: a modified Pettifor chemical scale from data mining</p>"},{"location":"reference/#oliynkyk","title":"Oliynkyk","text":"<p>The following paper describes the details: High-Throughput Machine-Learning-Driven Synthesis of Full-Heusler Compounds</p> <p>The 44 features of the embedding vector are formed of the following properties:</p>  Click to see the 44 features!  * Number * Atomic_Weight * Period * Group * Families * Metal * Nonmetal * Metalliod * Mendeleev_Number * l_quantum_number * Atomic_Radius * Miracle_Radius_[pm] * Covalent_Radius * Zunger_radii_sum * Ionic_radius * crystal_radius * Pauling_Electronegativity * MB_electonegativity * Gordy_electonegativity * Mulliken_EN * Allred-Rockow_electronegativity * Metallic_valence * Number_of_valence_electrons * Gilmor_number_of_valence_electron * valence_s * valence_p * valence_d * valence_f * Number_of_unfilled_s_valence_electrons * Number_of_unfilled_p_valence_electrons * Number_of_unfilled_d_valence_electrons * Number_of_unfilled_f_valence_electrons * Outer_shell_electrons * 1st_ionization_potential_(kJ/mol) * Polarizability(A^3) * Melting_point_(K) * Boiling_Point_(K) * Density_(g/mL) * Specific_heat_(J/g_K)_ * Heat_of_fusion_(kJ/mol)_ * Heat_of_vaporization_(kJ/mol)_ * Thermal_conductivity_(W/(m_K))_ * Heat_atomization(kJ/mol) * Cohesive_energy  <ul> <li><code>oliynyk_sc</code> is scaled version of the oliynyk embeddings</li> </ul>"},{"location":"reference/#random","title":"Random","text":"<p>This is a set of 200-dimensional vectors in which the components are randomly generated</p> <p>The 118 200-dimensional vectors in <code>random_200_new</code> was generated using the following code:</p> <pre><code>import numpy as np\nmu , sigma = 0 , 0.1 # mean and standard deviation s = np.random.normal(mu, sigma, 1000)\ns = np.random.default_rng(seed=42).normal(mu, sigma, (118,200))\n</code></pre>"},{"location":"reference/#skipatom","title":"SkipAtom","text":"<p>The following paper describes the details: Distributed representations of atoms and materials for machine learning</p>"},{"location":"tutorials/","title":"Tutorial","text":"<p>Here we will demonstrate how to use some of <code>AtomicEmbeddings</code>'s features. For full worked examples of using the package, please refer to the Jupyter notebooks in the examples section of the Github repo.</p>"},{"location":"tutorials/#atomic_embeddings","title":"Atomic_Embeddings","text":"<p>The <code>Embedding</code> class lies at the heart of the package. It handles elemental representation data and enables analysis and visualisation.</p> <pre><code>from AtomicEmbeddings.core import Embedding \n# Load the magpie data\nmagpie = Embedding.load_data('magpie')\n# Print out some of the properties of the Atomic_Embeddings class\n# Print the dimensions of the embedding\nprint(f'The magpie representation has embeddings of dimension {magpie.dim} \\n') \nprint(magpie.element_list) # prints out all the elements considered for this representation\nThe magpie representation has embeddings of dimension 21\n['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk']\n</code></pre>"},{"location":"python_api/composition/","title":"Composition module","text":"<p>This module provides a class for handling compositional embeddings.</p> Typical usage example <p>Fe2O3_magpie = CompositionalEmbedding(\"Fe2O3\", \"magpie\")</p>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding","title":"<code>CompositionalEmbedding</code>","text":"<p>Class to handle compositional embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>A string formula e.g. CsPbI3, Li7La3Zr2O12</p> required <code>embedding</code> <code>Union[str, Embedding]</code> <p>Either a string name of the embedding</p> required <code>x</code> <code>int</code> <p>The non-stoichiometric amount.</p> <code>1</code> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>class CompositionalEmbedding:\n\"\"\"\n    Class to handle compositional embeddings.\n    Args:\n        formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12\n        embedding (Union[str, Embedding]): Either a string name of the embedding\n        or an Embedding instance\n        x (int, optional): The non-stoichiometric amount.\n    \"\"\"\ndef __init__(self, formula: str, embedding: Union[str, Embedding], x=1):\n\"\"\"Initialise a CompositionalEmbedding instance.\"\"\"\nself.embedding = embedding\n# If a string has been passed for embedding, create an Embedding instance\nif isinstance(embedding, str):\nself.embedding = Embedding.load_data(embedding)\nself.embedding_name: str = self.embedding.embedding_name\n# Set an attribute for the formula\nself.formula = formula\n# Set an attribute for the comp dict\ncomp_dict = formula_parser(self.formula)\nself._natoms = 0\nfor el, v in comp_dict.items():\nif v &lt; 0:\nraise ValueError(\"Formula cannot contain negative amounts of elements\")\nself._natoms += abs(v)\nself.composition = comp_dict\n# Set an attribute for the element list\nself.element_list = list(self.composition.keys())\n# Set an attribute for the element matrix\nself.el_matrix = np.zeros(\nshape=(len(self.composition), len(self.embedding.embeddings[\"H\"]))\n)\nfor i, k in enumerate(self.composition.keys()):\nself.el_matrix[i] = self.embedding.embeddings[k]\nself.el_matrix = np.nan_to_num(self.el_matrix)\n# Set an attribute for the stoichiometric vector\nself.stoich_vector = np.array(list(self.composition.values()))\n# Set an attribute for the normalised stoichiometric vector\nself.norm_stoich_vector = self.stoich_vector / self._natoms\n@property\ndef fractional_composition(self):\n\"\"\"Fractional composition of the Composition.\"\"\"\nreturn _get_fractional_composition(self.formula)\n@property\ndef num_atoms(self) -&gt; float:\n\"\"\"Total number of atoms in Composition.\"\"\"\nreturn self._natoms\n@property\ndef embedding_dim(self) -&gt; int:\n\"\"\"Dimension of the embedding.\"\"\"\nreturn self.embedding.dim\ndef as_dict(self) -&gt; dict:\n# TO-DO: Need to create a dict representation for the embedding class\n\"\"\"Return the CompositionalEmbedding class as a dict.\"\"\"\nreturn {\n\"formula\": self.formula,\n\"composition\": self.composition,\n\"fractional_composition\": self.fractional_composition,\n# 'embedding':self.embedding.as_\n}\n# Se\n# Set an attribute\npass\ndef _mean_feature_vector(self) -&gt; np.ndarray:\n\"\"\"\n        Compute a weighted mean feature vector based of the embedding.\n        The dimension of the feature vector is the same as the embedding.\n        \"\"\"\nreturn np.dot(self.norm_stoich_vector, self.el_matrix)\ndef _variance_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute a weighted variance feature vector.\"\"\"\ndiff_matrix = self.el_matrix - self._mean_feature_vector()\ndiff_matrix = diff_matrix**2\nreturn np.dot(self.norm_stoich_vector, diff_matrix)\ndef _minpool_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute a min pooled feature vector.\"\"\"\nreturn np.min(self.el_matrix, axis=0)\ndef _maxpool_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute a max pooled feature vector.\"\"\"\nreturn np.max(self.el_matrix, axis=0)\ndef _range_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute a range feature vector.\"\"\"\nreturn np.ptp(self.el_matrix, axis=0)\ndef _sum_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute the weighted sum feature vector.\"\"\"\nreturn np.dot(self.stoich_vector, self.el_matrix)\ndef _geometric_mean_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute the geometric mean feature vector.\"\"\"\nreturn np.exp(np.dot(self.norm_stoich_vector, np.log(self.el_matrix)))\ndef _harmonic_mean_feature_vector(self) -&gt; np.ndarray:\n\"\"\"Compute the harmonic mean feature vector.\"\"\"\nreturn np.reciprocal(\nnp.dot(self.norm_stoich_vector, np.reciprocal(self.el_matrix))\n)\n_stats_functions_dict = {\n\"mean\": \"_mean_feature_vector\",\n\"variance\": \"_variance_feature_vector\",\n\"minpool\": \"_minpool_feature_vector\",\n\"maxpool\": \"_maxpool_feature_vector\",\n\"range\": \"_range_feature_vector\",\n\"sum\": \"_sum_feature_vector\",\n\"geometric_mean\": \"_geometric_mean_feature_vector\",\n\"harmonic_mean\": \"_harmonic_mean_feature_vector\",\n}\ndef feature_vector(self, stats: Union[str, list] = [\"mean\"]):\n\"\"\"\n        Compute a feature vector.\n        The feature vector is a concatenation of\n        the statistics specified in the stats argument.\n        Args:\n            stats (list): A list of strings specifying the statistics to be computed.\n            The default is ['mean'].\n        Returns:\n            np.ndarray: A feature vector of dimension (len(stats) * embedding_dim).\n        \"\"\"\nimplemented_stats = [\n\"mean\",\n\"variance\",\n\"minpool\",\n\"maxpool\",\n\"range\",\n\"sum\",\n\"geometric_mean\",\n\"harmonic_mean\",\n]\nif isinstance(stats, str):\nstats = [stats]\nif not isinstance(stats, list):\nraise ValueError(\"Stats argument must be a list of strings\")\nif not all([isinstance(s, str) for s in stats]):\nraise ValueError(\"Stats argument must be a list of strings\")\nif not all([s in implemented_stats for s in stats]):\nraise ValueError(\nf\" {[stat for stat in stats if stat not in implemented_stats]} \"\n\"are not valid statistics.\"\n)\nfeature_vector = []\nfor s in stats:\nfeature_vector.append(getattr(self, self._stats_functions_dict[s])())\nreturn np.concatenate(feature_vector)\ndef __repr__(self):\nreturn (\nf\"CompositionalEmbedding(formula={self.formula}, \"\nf\"embedding={self.embedding})\"\n)\ndef __str__(self):\nreturn (\nf\"CompositionalEmbedding(formula={self.formula}, \"\nf\"embedding={self.embedding})\"\n)\ndef __eq__(self, other):\nif isinstance(other, self.__class__):\nreturn self.formula == other.formula and self.embedding == other.embedding\nelse:\nreturn False\ndef __ne__(self, other):\nreturn not self.__eq__(other)\ndef __hash__(self):\nreturn hash((self.formula, self.embedding))\n</code></pre>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.embedding_dim","title":"<code>embedding_dim: int</code>  <code>property</code>","text":"<p>Dimension of the embedding.</p>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.fractional_composition","title":"<code>fractional_composition</code>  <code>property</code>","text":"<p>Fractional composition of the Composition.</p>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.num_atoms","title":"<code>num_atoms: float</code>  <code>property</code>","text":"<p>Total number of atoms in Composition.</p>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.__init__","title":"<code>__init__(formula, embedding, x=1)</code>","text":"<p>Initialise a CompositionalEmbedding instance.</p> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>def __init__(self, formula: str, embedding: Union[str, Embedding], x=1):\n\"\"\"Initialise a CompositionalEmbedding instance.\"\"\"\nself.embedding = embedding\n# If a string has been passed for embedding, create an Embedding instance\nif isinstance(embedding, str):\nself.embedding = Embedding.load_data(embedding)\nself.embedding_name: str = self.embedding.embedding_name\n# Set an attribute for the formula\nself.formula = formula\n# Set an attribute for the comp dict\ncomp_dict = formula_parser(self.formula)\nself._natoms = 0\nfor el, v in comp_dict.items():\nif v &lt; 0:\nraise ValueError(\"Formula cannot contain negative amounts of elements\")\nself._natoms += abs(v)\nself.composition = comp_dict\n# Set an attribute for the element list\nself.element_list = list(self.composition.keys())\n# Set an attribute for the element matrix\nself.el_matrix = np.zeros(\nshape=(len(self.composition), len(self.embedding.embeddings[\"H\"]))\n)\nfor i, k in enumerate(self.composition.keys()):\nself.el_matrix[i] = self.embedding.embeddings[k]\nself.el_matrix = np.nan_to_num(self.el_matrix)\n# Set an attribute for the stoichiometric vector\nself.stoich_vector = np.array(list(self.composition.values()))\n# Set an attribute for the normalised stoichiometric vector\nself.norm_stoich_vector = self.stoich_vector / self._natoms\n</code></pre>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the CompositionalEmbedding class as a dict.</p> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>def as_dict(self) -&gt; dict:\n# TO-DO: Need to create a dict representation for the embedding class\n\"\"\"Return the CompositionalEmbedding class as a dict.\"\"\"\nreturn {\n\"formula\": self.formula,\n\"composition\": self.composition,\n\"fractional_composition\": self.fractional_composition,\n# 'embedding':self.embedding.as_\n}\n# Se\n# Set an attribute\npass\n</code></pre>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.CompositionalEmbedding.feature_vector","title":"<code>feature_vector(stats=['mean'])</code>","text":"<p>Compute a feature vector.</p> <p>The feature vector is a concatenation of the statistics specified in the stats argument.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>list</code> <p>A list of strings specifying the statistics to be computed.</p> <code>['mean']</code> <p>Returns:</p> Type Description <p>np.ndarray: A feature vector of dimension (len(stats) * embedding_dim).</p> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>def feature_vector(self, stats: Union[str, list] = [\"mean\"]):\n\"\"\"\n    Compute a feature vector.\n    The feature vector is a concatenation of\n    the statistics specified in the stats argument.\n    Args:\n        stats (list): A list of strings specifying the statistics to be computed.\n        The default is ['mean'].\n    Returns:\n        np.ndarray: A feature vector of dimension (len(stats) * embedding_dim).\n    \"\"\"\nimplemented_stats = [\n\"mean\",\n\"variance\",\n\"minpool\",\n\"maxpool\",\n\"range\",\n\"sum\",\n\"geometric_mean\",\n\"harmonic_mean\",\n]\nif isinstance(stats, str):\nstats = [stats]\nif not isinstance(stats, list):\nraise ValueError(\"Stats argument must be a list of strings\")\nif not all([isinstance(s, str) for s in stats]):\nraise ValueError(\"Stats argument must be a list of strings\")\nif not all([s in implemented_stats for s in stats]):\nraise ValueError(\nf\" {[stat for stat in stats if stat not in implemented_stats]} \"\n\"are not valid statistics.\"\n)\nfeature_vector = []\nfor s in stats:\nfeature_vector.append(getattr(self, self._stats_functions_dict[s])())\nreturn np.concatenate(feature_vector)\n</code></pre>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.composition_featuriser","title":"<code>composition_featuriser(data, embedding='magpie', stats=['mean'], inplace=False)</code>","text":"<p>Compute a feature vector for a composition.</p> <p>The feature vector is based on the statistics specified in the stats argument.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[pd.DataFrame, pd.Series, list, CompositionalEmbedding]</code> required <code>embedding</code> <code>Union[Embedding, str]</code> <p>A Embedding class or a string</p> <code>'magpie'</code> <code>stats</code> <code>Union[str, list]</code> <p>A list of statistics to be computed.</p> <code>['mean']</code> <code>inplace</code> <code>bool</code> <p>Whether to perform the operation in place on the data.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector,</p> <code>pd.DataFrame</code> <p>or a list of feature vectors is returned</p> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>def composition_featuriser(\ndata: Union[pd.DataFrame, pd.Series, CompositionalEmbedding, list],\nembedding: Union[Embedding, str] = \"magpie\",\nstats: Union[str, list] = [\"mean\"],\ninplace: bool = False,\n) -&gt; pd.DataFrame:\n\"\"\"\n    Compute a feature vector for a composition.\n    The feature vector is based on the statistics specified\n    in the stats argument.\n    Args:\n        data (Union[pd.DataFrame, pd.Series, list, CompositionalEmbedding]):\n        A pandas DataFrame or Series containing a column named 'formula',\n        a list of formula, or a CompositionalEmbedding class\n        embedding (Union[Embedding, str], optional): A Embedding class or a string\n        stats (Union[str, list], optional): A list of statistics to be computed.\n        The default is ['mean'].\n        inplace (bool, optional): Whether to perform the operation in place on the data.\n        The default is False.\n    Returns:\n        Union[pd.DataFrame,list]: A pandas DataFrame containing the feature vector,\n        or a list of feature vectors is returned\n    \"\"\"\nif isinstance(data, pd.DataFrame):\nif not inplace:\ndata = data.copy()\nif \"formula\" not in data.columns:\nraise ValueError(\n\"The data must contain a column named 'formula' to featurise.\"\n)\ndata[\"composition\"] = data[\"formula\"].progress_apply(\nlambda x: CompositionalEmbedding(x, embedding)\n)\ndata[\"feature_vector\"] = data[\"composition\"].progress_apply(\nlambda x: x.feature_vector(stats)\n)\ndata.drop(\"composition\", axis=1, inplace=True)\nreturn data\nelif isinstance(data, pd.Series):\nif not inplace:\ndata = data.copy()\ndata[\"composition\"] = data[\"formula\"].progress_apply(\nlambda x: CompositionalEmbedding(x, embedding)\n)\ndata[\"feature_vector\"] = data[\"composition\"].progress_apply(\nlambda x: x.feature_vector(stats)\n)\ndata.drop(\"composition\", axis=1, inplace=True)\nreturn data\nelif isinstance(data, list):\ncomps = [CompositionalEmbedding(x, embedding) for x in data]\nreturn [x.feature_vector(stats) for x in tqdm(comps)]\nelif isinstance(data, CompositionalEmbedding):\nreturn data.feature_vector(stats)\nelse:\nraise ValueError(\n\"The data must be a pandas DataFrame, Series, \"\n\"list or CompositionalEmbedding class.\"\n)\n</code></pre>"},{"location":"python_api/composition/#AtomicEmbeddings.composition.formula_parser","title":"<code>formula_parser(formula)</code>","text":"<p>Parse a string formula.</p> <p>Returns a dictionary of the composition with key:value pairs of element symbol:amount.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>A string formula e.g. CsPbI3, Li7La3Zr2O12</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the composition</p> Source code in <code>AtomicEmbeddings/composition.py</code> <pre><code>def formula_parser(formula: str) -&gt; Dict[str, float]:\n# TO-DO: Add validation to check composition contains real elements.\n\"\"\"\n    Parse a string formula.\n    Returns a dictionary of the composition with key:value pairs\n    of element symbol:amount.\n    Args:\n        formula (str): A string formula e.g. CsPbI3, Li7La3Zr2O12\n    Returns:\n        (dict): A dictionary of the composition\n    \"\"\"\n# For Metallofullerene\nformula = formula.replace(\"@\", \"\")\nregex = r\"\\(([^\\(\\)]+)\\)\\s*([\\.e\\d]*)\"\nr = re.compile(regex)\nm = re.search(r, formula)\nif m:\nfactor = 1.0\nif m.group(2) != \"\":\nfactor = float(m.group(2))\nunit_sym_dict = _get_sym_dict(m.group(1), factor)\nexpanded_sym = \"\".join([f\"{el}{amt}\" for el, amt in unit_sym_dict.items()])\nexpanded_formula = formula.replace(m.group(), expanded_sym)\nreturn formula_parser(expanded_formula)\nreturn _get_sym_dict(formula, 1)\n</code></pre>"},{"location":"python_api/core/","title":"Core module","text":"<p>Provides the <code>Embedding</code> class.</p> <p>This module enables the user load in elemetal representation data and analyse it using statistical functions.</p> Typical usage example <p>megnet16 = Embedding.load_data('megnet16')</p>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding","title":"<code>Embedding</code>","text":"<p>Represent an elemental representation.</p> <p>To load an embedding distributed from the package use the load_data() method.</p> <p>Works like a standard python dictionary. The keys are {element: vector} pairs.</p> <p>Adds a few convenience methods related to elemental representations.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>class Embedding:\n\"\"\"\n    Represent an elemental representation.\n    To load an embedding distributed from the package use the load_data() method.\n    Works like a standard python dictionary. The keys are {element: vector} pairs.\n    Adds a few convenience methods related to elemental representations.\n    \"\"\"\ndef __init__(self, embeddings: dict, embedding_name: Optional[str] = None):\n\"\"\"Initialise the Embedding class.\n        Args:\n            embeddings (dict): A {element_symbol: vector} dictionary\n            embedding_name (str): The name of the elemental representation\n        \"\"\"\nself.embeddings = embeddings\nself.embedding_name = embedding_name\n# Grab a random value from the embedding vector\n_rand_embed = random.choice(list(self.embeddings.values()))\n# Convert embeddings to numpy array if not already a numpy array\nif not isinstance(_rand_embed, np.ndarray):\nself.embeddings = {\nele: np.array(self.embeddings[ele]) for ele in self.embeddings\n}\n# Determines if the embedding vector has a length attribute\n# (i.e. is not a scalar int or float)\n# If the 'vector' is a scalar/float, the representation is linear (dim=1)\nif hasattr(_rand_embed, \"__len__\") and (not isinstance(_rand_embed, str)):\nself.dim: int = len(random.choice(list(self.embeddings.values())))\nelse:\nself.dim: int = int(1)\n# Dummy initialisation for results\nself._data = []\nself._pca_data = None  # type: Optional[np.ndarray]\nself._tsne_data = None  # type: Optional[np.ndarray]\nself._umap_data = None  # type: Optional[np.ndarray]\n@staticmethod\ndef load_data(embedding_name: Optional[str] = None):\n\"\"\"\n        Create an instance of the `Embedding` class from a default embedding file.\n        The default embeddings are in the table below:\n        | **Name**                | **str_name** |\n        |-------------------------|--------------|\n        | Magpie                  | magpie       |\n        | Magpie (scaled)         | magpie_sc    |\n        | Mat2Vec                 | mat2vec      |\n        | Matscholar              | matscholar   |\n        | Megnet (16 dimensions)  | megnet16     |\n        | Modified pettifor scale | mod_petti    |\n        | Oliynyk                 | oliynyk      |\n        | Oliynyk (scaled)        | oliynyk_sc   |\n        | Random (200 dimensions) | random_200   |\n        | SkipAtom                | skipatom     |\n        Args:\n            embedding_name (str): The str_name of an embedding file.\n        Returns:\n            Embedding :class:`Embedding` instance.\n        \"\"\"\n_cbfv_files = {\n\"magpie\": \"magpie.csv\",\n\"magpie_sc\": \"magpie_sc.json\",\n\"mat2vec\": \"mat2vec.csv\",\n\"matscholar\": \"matscholar-embedding.json\",\n\"megnet16\": \"megnet16.json\",\n\"mod_petti\": \"mod_petti.json\",\n\"oliynyk\": \"oliynyk.json\",\n\"oliynyk_sc\": \"oliynyk_sc.json\",\n\"random_200\": \"random_200_new.csv\",\n\"skipatom\": \"skipatom_20201009_induced.csv\",\n}\n_cbfv_names = list(_cbfv_files.keys())\n_cbfv_names_others = [\ni\nfor i in _cbfv_names\nif i not in [\"skipatom\", \"random_200\", \"megnet16\", \"magpie\", \"mat2vec\"]\n]\n# Get the embeddings\nif embedding_name in _cbfv_files:\nif embedding_name in [\"skipatom\", \"random_200\", \"magpie\", \"mat2vec\"]:\n_csv = path.join(data_directory, _cbfv_files[embedding_name])\ndf = pd.read_csv(_csv)\n# Convert df to a dictionary of (ele:embeddings) pairs\nelements = list(df[\"element\"])\ndf.drop([\"element\"], axis=1, inplace=True)\nembeds_array = df.to_numpy()\nembedding_data = {\nelements[i]: embeds_array[i] for i in range(len(embeds_array))\n}\nelif embedding_name == \"megnet16\":\nmegnet16_json = path.join(data_directory, _cbfv_files[\"megnet16\"])\nwith open(megnet16_json) as f:\nembedding_data = json.load(f)\n# Remove 'Null' key from megnet embedding\ndel embedding_data[\"Null\"]\nelif embedding_name in _cbfv_names_others:\n_json = path.join(data_directory, _cbfv_files[embedding_name])\nwith open(_json) as f:\nembedding_data = json.load(f)\n# Load a json file from a file specified in the input\nelse:\nwith open(embedding_name) as f:\nembedding_data = json.load(f)\nelse:\nraise (\nValueError(\nf\"{embedding_name} not in the data directory or not in directory.\"\n)\n)\nreturn Embedding(embedding_data, embedding_name)\n@staticmethod\ndef from_json(embedding_json):\n\"\"\"\n        Create an instance of the Embedding class from a json file.\n        Args:\n            embedding_json (str): Filepath of the json file\n        \"\"\"\n# Need to add validation handling for JSONs in different formats\nwith open(embedding_json) as f:\nembedding_data = json.load(f)\nreturn Embedding(embedding_data)\n@staticmethod\ndef from_csv(embedding_csv):\n\"\"\"\n        Create an instance of the Embedding class from a csv file.\n        The first column of the csv file must contain the elements and be named element.\n        Args:\n            embedding_csv (str): Filepath of the csv file\n        \"\"\"\n# Need to add validation handling for csv files\ndf = pd.read_csv(embedding_csv)\nelements = list(df[\"element\"])\ndf.drop([\"element\"], axis=1, inplace=True)\nembeds_array = df.to_numpy()\nembedding_data = {\nelements[i]: embeds_array[i] for i in range(len(embeds_array))\n}\nreturn Embedding(embedding_data)\ndef as_dataframe(self, columns: str = \"components\") -&gt; pd.DataFrame:\n\"\"\"\n        Return the embedding as a pandas Dataframe.\n        The first column is the elements and each other\n        column represents a component of the embedding.\n        Args:\n            columns (str): A string to specify if the columns are the vector components\n            and the index is the elements (`columns='components')\n            or the columns are the elements (`columns='elements'`).\n        Returns:\n            df (pandas.DataFrame): A pandas dataframe object\n        \"\"\"\nembedding = self.embeddings\ndf = pd.DataFrame(embedding)\nif columns == \"components\":\nreturn df.T\nelif columns == \"elements\":\nreturn df\nelse:\nraise (\nValueError(\nf\"{columns} is not a valid keyword argument. \"\n\"Choose either 'components' or 'elements\"\n)\n)\ndef to(self, fmt: str = \"\", filename: Optional[str] = \"\"):\n\"\"\"\n        Output the embedding to a file.\n        Args:\n            fmt (str): The file format to output the embedding to.\n            Options include \"json\" and \"csv\".\n            filename (str): The name of the file to be outputted\n        Returns:\n            (str) if filename not specified, otherwise None.\n        \"\"\"\nfmt = fmt.lower()\nif fmt == \"json\" or fnmatch.fnmatch(filename, \"*.json\"):\nj = json.dumps(self.embeddings, cls=NumpyEncoder)\nif filename:\nif not filename.endswith(\".json\"):\nfilename = filename + \".json\"\nwith open(filename, \"w\") as file:\nfile.write(j)\nelse:\nreturn j\nelif fmt == \"csv\" or fnmatch.fnmatch(filename, \"*.csv\"):\nif filename:\nif not filename.endswith(\".csv\"):\nfilename = filename + \".csv\"\nself.as_dataframe().to_csv(filename, index_label=\"element\")\nelse:\nreturn self.as_dataframe().to_csv(index_label=\"element\")\nelse:\nraise ValueError(f\"{str(fmt)} is an invalid file format\")\n@property\ndef element_list(self) -&gt; list:\n\"\"\"Return the elements of the embedding.\"\"\"\nreturn list(self.embeddings.keys())\ndef remove_elements(self, elements: Union[str, List[str]], inplace: bool = False):\n# TO-DO allow removal by atomic numbers\n\"\"\"\n        Remove elements from the Embedding instance.\n        Args:\n            elements (str,list(str)): An element symbol or a list of element symbols\n            inplace (bool): If True, elements are removed from the Embedding instance.\n            If false, the original embedding instance is unchanged\n            and a new embedding instance with the elements removed is created.\n        \"\"\"\nif inplace:\nif isinstance(elements, str):\ndel self.embeddings[elements]\nelif isinstance(elements, list):\nfor el in elements:\ndel self.embeddings[el]\nreturn None\nelse:\nembeddings_copy = self.embeddings.copy()\nif isinstance(elements, str):\ndel embeddings_copy[elements]\nelif isinstance(elements, list):\nfor el in elements:\ndel embeddings_copy[el]\nreturn Embedding(embeddings_copy, self.embedding_name)\ndef citation(self) -&gt; List[str]:\n\"\"\"Return a citation for the embedding.\"\"\"\nif self.embedding_name in [\"magpie\", \"magpie_sc\"]:\ncitation = [\n\"@article{ward2016general,\"\n\"title={A general-purpose machine learning framework for \"\n\"predicting properties of inorganic materials},\"\n\"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \"\n\"and Wolverton, Christopher},\"\n\"journal={npj Computational Materials},\"\n\"volume={2},\"\n\"number={1},\"\n\"pages={1--7},\"\n\"year={2016},\"\n\"publisher={Nature Publishing Group}}\"\n]\nelif self.embedding_name == \"mat2vec\":\ncitation = [\n\"@article{tshitoyan2019unsupervised,\"\n\"title={Unsupervised word embeddings capture latent knowledge \"\n\"from materials science literature},\"\n\"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \"\n\"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \"\n\"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\"\n\"journal={Nature},\"\n\"volume={571},\"\n\"number={7763},\"\n\"pages={95--98},\"\n\"year={2019},\"\n\"publisher={Nature Publishing Group} }\"\n]\nelif self.embedding_name == \"matscholar\":\ncitation = [\n\"@article{weston2019named,\"\n\"title={Named entity recognition and normalization applied to \"\n\"large-scale information extraction from the materials \"\n\"science literature},\"\n\"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \"\n\"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \"\n\"Ceder, Gerbrand and Jain, Anubhav},\"\n\"journal={Journal of chemical information and modeling},\"\n\"volume={59},\"\n\"number={9},\"\n\"pages={3692--3702},\"\n\"year={2019},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name == \"megnet16\":\ncitation = [\n\"@article{chen2019graph,\"\n\"title={Graph networks as a universal machine learning framework \"\n\"for molecules and crystals},\"\n\"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \"\n\"Zheng, Chen and Ong, Shyue Ping},\"\n\"journal={Chemistry of Materials},\"\n\"volume={31},\"\n\"number={9},\"\n\"pages={3564--3572},\"\n\"year={2019},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name in [\"oliynyk\", \"oliynyk_sc\"]:\ncitation = [\n\"              @article{oliynyk2016high,\"\n\"title={High-throughput machine-learning-driven synthesis \"\n\"of full-Heusler compounds},\"\n\"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \"\n\"Ghadbeigi, Leila and Gaultois, Michael W and \"\n\"Meredig, Bryce and Mar, Arthur},\"\n\"journal={Chemistry of Materials},\"\n\"volume={28},\"\n\"number={20},\"\n\"pages={7324--7331},\"\n\"year={2016},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name == \"skipatom\":\ncitation = [\n\"@article{antunes2022distributed,\"\n\"title={Distributed representations of atoms and materials \"\n\"for machine learning},\"\n\"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\"\n\"journal={npj Computational Materials},\"\n\"volume={8},\"\n\"number={1},\"\n\"pages={1--9},\"\n\"year={2022},\"\n\"publisher={Nature Publishing Group} }\"\n]\nelif self.embedding_name == \"mod_petti\":\ncitation = [\n\"@article{glawe2016optimal,\"\n\"title={The optimal one dimensional periodic table: \"\n\"a modified Pettifor chemical scale from data mining},\"\n\"author={Glawe, Henning and Sanna, Antonio and Gross, \"\n\"EKU and Marques, Miguel AL},\"\n\"journal={New Journal of Physics},\"\n\"volume={18},\"\n\"number={9},\"\n\"pages={093011},\"\n\"year={2016},\"\n\"publisher={IOP Publishing} }\"\n]\nelse:\ncitation = []\nreturn citation\ndef _is_el_in_embedding(self, el: str) -&gt; bool:\n\"\"\"\n        Check if an element is in the `Embedding` object.\n        Args:\n            el (str): An element symbol\n        Returns:\n            bool: True if el is in the Embedding, else False\n        \"\"\"\nif el in self.element_list:\nreturn True\nelse:\nreturn False\n@property\ndef element_groups_dict(self) -&gt; Dict[str, str]:\n\"\"\"\n        Return a dictionary of {element: element type} pairs.\n        e.g. {'He':'Noble gas'}\n        \"\"\"\nwith open(path.join(data_directory, \"element_data/element_group.json\")) as f:\n_dict = json.load(f)\nreturn {i: _dict[i] for i in self.element_list}\ndef create_pairs(self):\n\"\"\"Create all possible pairs of elements.\"\"\"\nele_list = self.element_list\nele_pairs = combinations_with_replacement(ele_list, 2)\nreturn ele_pairs\ndef stats_correlation_df(self) -&gt; pd.DataFrame:\n\"\"\"Return a pandas.DataFrame with correlation metrics.\n         The columns of returned dataframe are:\n        [element_1, element_2, pearson_corr, euclid_dist].\n        \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\npearson = pearsonr(self.embeddings[ele1], self.embeddings[ele2])\ndist = norm(self.embeddings[ele1] - self.embeddings[ele2])\ntable.append((ele1, ele2, pearson[0], dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, pearson[0], dist))\ncorr_df = pd.DataFrame(\ntable,\ncolumns=[\n\"ele_1\",\n\"ele_2\",\n\"pearson_corr\",\n\"euclid_dist\",\n],\n)\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df = corr_df[\n[\n\"ele_1\",\n\"ele_2\",\n\"mend_1\",\n\"mend_2\",\n\"euclid_dist\",\n\"pearson_corr\",\n]\n]\nreturn corr_df\ndef compute_correlation_metric(\nself, ele1: str, ele2: str, metric: str = \"pearson\"\n) -&gt; Union[PearsonRResult, SpearmanrResult, float]:\n\"\"\"\n        Compute the correlation/similarity metric between two vectors.\n        Allowed metrics:\n        * Pearson\n        * Spearman\n        * Cosine similarity\n        Args:\n            ele1 (str): element symbol\n            ele2 (str): element symbol\n            metric (str): name of a correlation metric.\n            Options are \"spearman\", \"pearson\" and \"cosine_similarity\".\n        Returns:\n            PearsonResult | SpearmanrResult | float: correlation/similarity metric\n        \"\"\"\n# Define the allowable metrics\nscipy_corrs = {\"pearson\": pearsonr, \"spearman\": spearmanr}\nif metric in scipy_corrs:\nreturn scipy_corrs[metric](self.embeddings[ele1], self.embeddings[ele2])\nelif metric == \"cosine_similarity\":\nreturn cosine_similarity(self.embeddings[ele1], self.embeddings[ele2])\ndef compute_distance_metric(\nself, ele1: str, ele2: str, metric: str = \"euclidean\"\n) -&gt; float:\n\"\"\"\n        Compute distance metric between two vectors.\n        Allowed metrics:\n        * euclidean\n        * manhattan\n        * chebyshev\n        * wasserstein\n        * energy\n        * cosine_distance\n        Args:\n            ele1 (str): element symbol\n            ele2 (str): element symbol\n            metric (str): name of a distance metric\n        Returns:\n            distance (float): distance between embedding vectors\n        \"\"\"\n# Define the allowable metrics\nscikit_metrics = [\"euclidean\", \"manhattan\", \"chebyshev\"]\nscipy_metrics = {\"wasserstein\": wasserstein_distance, \"energy\": energy_distance}\nvalid_metrics = scikit_metrics + list(scipy_metrics.keys()) + [\"cosine\"]\n# Validate if the elements are within the embedding vector\nif not all([self._is_el_in_embedding(ele1), self._is_el_in_embedding(ele2)]):\nif not self._is_el_in_embedding(ele1):\nprint(f\"{ele1} is not an element included within the atomic embeddings\")\nraise ValueError\nelif not self._is_el_in_embedding(ele2):\nprint(f\"{ele2} is not an element included within the atomic embeddings\")\nraise ValueError\n# Compute the distance measure\nif metric in scikit_metrics:\ndistance = DistanceMetric.get_metric(metric)\nreturn distance.pairwise(\nself.embeddings[ele1].reshape(1, -1),\nself.embeddings[ele2].reshape(1, -1),\n)[0][0]\nelif metric in scipy_metrics.keys():\nreturn scipy_metrics[metric](self.embeddings[ele1], self.embeddings[ele2])\nelif metric == \"cosine_distance\":\nreturn cosine_distance(self.embeddings[ele1], self.embeddings[ele2])\nelse:\nprint(\n\"Invalid distance metric.\"\nf\"Use one of the following metrics:{valid_metrics}\"\n)\nraise ValueError\ndef pearson_pivot_table(self) -&gt; pd.DataFrame:\n\"\"\"\n        Return a pandas.DataFrame style pivot object.\n        The index and column are the mendeleev number of the element pairs\n        and the values being the pearson correlation metrics.\n        \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\ncorr_df = self.correlation_df()\npearson_pivot = corr_df.pivot_table(\nvalues=\"pearson_corr\", index=\"mend_1\", columns=\"mend_2\"\n)\nreturn pearson_pivot\ndef distance_df(self, metric: str = \"euclidean\") -&gt; pd.DataFrame:\n\"\"\"\n        Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].\n        Allowed metrics:\n        * euclidean\n        * manhattan\n        * chebyshev\n        * wasserstein\n        * energy\n        Args:\n            metric (str): A distance metric.\n        Returns:\n            df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric].\n        \"\"\"\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\ndist = self.compute_distance_metric(ele1, ele2, metric=metric)\ntable.append((ele1, ele2, dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, dist))\ncorr_df = pd.DataFrame(table, columns=[\"ele_1\", \"ele_2\", metric])\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\nZ_1 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_1\"]]\nZ_2 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df[\"Z_1\"] = Z_1\ncorr_df[\"Z_2\"] = Z_2\ncorr_df = corr_df[[\"ele_1\", \"ele_2\", \"mend_1\", \"mend_2\", \"Z_1\", \"Z_2\", metric]]\nreturn corr_df\ndef correlation_df(self, metric: str = \"pearson\") -&gt; pd.DataFrame:\n\"\"\"\n        Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].\n        Allowed metrics:\n        * pearson\n        * spearman\n        * cosine_similarity\n        Args:\n            metric (str): A distance metric.\n        Returns:\n            df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric].\n        \"\"\"\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\ndist = self.compute_correlation_metric(ele1, ele2, metric=metric)\nif metric in [\"pearson\", \"spearman\"]:\ndist = dist[0]\ntable.append((ele1, ele2, dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, dist))\ncorr_df = pd.DataFrame(table, columns=[\"ele_1\", \"ele_2\", metric])\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\nZ_1 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_1\"]]\nZ_2 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df[\"Z_1\"] = Z_1\ncorr_df[\"Z_2\"] = Z_2\ncorr_df = corr_df[[\"ele_1\", \"ele_2\", \"mend_1\", \"mend_2\", \"Z_1\", \"Z_2\", metric]]\nreturn corr_df\ndef distance_pivot_table(\nself, metric: str = \"euclidean\", sortby: str = \"mendeleev\"\n) -&gt; pd.DataFrame:\n\"\"\"\n        Return a pandas.DataFrame style pivot.\n        The index and column being either the mendeleev number or atomic number\n        of the element pairs and the values being a user-specified distance metric.\n        Args:\n            metric (str): A distance metric.\n            sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\".\n        Returns:\n            distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table.\n        \"\"\"\ncorr_df = self.distance_df(metric=metric)\nif sortby == \"mendeleev\":\ndistance_pivot = corr_df.pivot_table(\nvalues=metric, index=\"mend_1\", columns=\"mend_2\"\n)\nreturn distance_pivot\nelif sortby == \"atomic_number\":\ndistance_pivot = corr_df.pivot_table(\nvalues=metric, index=\"Z_1\", columns=\"Z_2\"\n)\nreturn distance_pivot\ndef correlation_pivot_table(\nself, metric: str = \"pearson\", sortby: str = \"mendeleev\"\n) -&gt; pd.DataFrame:\n\"\"\"\n        Return a pandas.DataFrame style pivot.\n        The index and column being either the mendeleev number or atomic number\n        of the element pairs and the values being a user-specified distance metric.\n        Args:\n            metric (str): A distance metric.\n            sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\".\n        Returns:\n            distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table.\n        \"\"\"\ncorr_df = self.correlation_df(metric=metric)\nif sortby == \"mendeleev\":\ncorrelation_pivot = corr_df.pivot_table(\nvalues=metric, index=\"mend_1\", columns=\"mend_2\"\n)\nreturn correlation_pivot\nelif sortby == \"atomic_number\":\ncorrelation_pivot = corr_df.pivot_table(\nvalues=metric, index=\"Z_1\", columns=\"Z_2\"\n)\nreturn correlation_pivot\ndef plot_pearson_correlation(self, figsize: Tuple[int, int] = (24, 24), **kwargs):\n\"\"\"\n        Plot the heatmap of the pearson correlation values.\n        Args:\n            figsize (tuple): A tuple of (width, height).\n            **kwargs: Other keyword arguments to be passed to sns.heatmap\n        Returns:\n            ax (matplotlib Axes): An Axes object with the heatmap\n        \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\npearson_pivot = self.pearson_pivot_table()\nplt.figure(figsize=figsize)\nax = sns.heatmap(\npearson_pivot, cmap=\"bwr\", square=True, linecolor=\"k\", **kwargs\n)\nreturn ax\ndef plot_distance_correlation(\nself, metric: str = \"euclidean\", figsize: Tuple[int, int] = (24, 24), **kwargs\n):\n\"\"\"\n        Plot the heatmap of the pairwise distance metrics.\n        Args:\n            metric (str): A valid distance metric\n            figsize (tuple): A tuple of (width, height)\n        Returns:\n            ax (matplotlib.axes.Axes): An Axes object with the heatmap\n        \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\ndistance_pivot = self.distance_pivot_table(metric=metric)\nplt.figure(figsize=figsize)\nax = sns.heatmap(\ndistance_pivot, cmap=\"bwr\", square=True, linecolor=\"k\", **kwargs\n)\nreturn ax\ndef calculate(self, mode: str = \"all\") -&gt; None:\n\"\"\"\n        Calculate the pairwise statistics of the elements present.\n        The pairwise statistics include the distance and correlation metrics\n        Args:\n            mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"`\n                will calculate all available distance and correlation metrics;\n                `mode=\"correlation\"` will only calculate correlation metrics\n                and `mode=\"distance\"` will only calculate distance metrics.\n        Returns:\n            None\n        \"\"\"\nele_pairs = self.create_pairs()\ntable = []\n# columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"]\nfor ele1, ele2 in ele_pairs:\ntemp_dict = {\"element_1\": ele1, \"element_2\": ele2}\ntable.append(temp_dict)\npass\ndef calculate_PC(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\npca = decomposition.PCA(\nn_components=n_components, **kwargs\n)  # project to N dimensions\npca.fit(embeddings_array)\nself._pca_data = pca.transform(embeddings_array)\nreturn self._pca_data\ndef calculate_tSNE(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate t-SNE components.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\ntsne = TSNE(n_components=n_components, **kwargs)\ntsne_result = tsne.fit_transform(embeddings_array)\nself._tsne_data = tsne_result\nreturn self._tsne_data\ndef calculate_UMAP(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate UMAP embeddings.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\numap = UMAP(n_components=n_components, **kwargs)\numap_result = umap.fit_transform(embeddings_array)\nself._umap_data = umap_result\nreturn self._umap_data\ndef plot_PCA_2D(\nself,\nfigsize: Tuple[int, int] = (16, 12),\npoints_hue: str = \"group\",\npoints_size: int = 200,\n**kwargs,\n):\n\"\"\"Plot a PCA plot of the atomic embedding.\n        Args:\n            figsize (tuple): A tuple of (width, height)\n            points_size (float): The marker size\n        Returns:\n            ax (matplotlib.axes.Axes): An Axes object with the PCA plot\n        \"\"\"\nembeddings_array = np.array(list(self.embeddings.values()))\nelement_array = np.array(self.element_list)\npca = decomposition.PCA(n_components=2)  # project to 2 dimensions\npca.fit(embeddings_array)\nX = pca.transform(embeddings_array)\npca_dim1 = X[:, 0]\npca_dim2 = X[:, 1]\n# Create a dataframe to store the dimensions, labels and group info for the PCA\npca_df = pd.DataFrame(\n{\n\"pca_dim1\": pca_dim1,\n\"pca_dim2\": pca_dim2,\n\"element\": element_array,\n\"group\": list(self.element_groups_dict.values()),\n}\n)\nfig, ax = plt.subplots(figsize=figsize)\nsns.scatterplot(\nx=\"pca_dim1\",\ny=\"pca_dim2\",\ndata=pca_df,\nhue=points_hue,\ns=points_size,\n**kwargs,\nax=ax,\n)\nplt.xlabel(\"Dimension 1\")\nplt.ylabel(\"Dimension 2\")\nfor i in range(len(X)):\nplt.text(x=pca_dim1[i], y=pca_dim2[i], s=element_array[i])\nreturn plt\ndef plot_tSNE(\nself,\nn_components: str = 2,\nfigsize: Tuple[int, int] = (16, 12),\npoints_hue: str = \"group\",\npoints_size: int = 200,\n**kwargs,\n):\n\"\"\"Plot a t-SNE plot of the atomic embedding.\n        Args:\n            n_components (int): Number of t-SNE components to plot.\n            figsize (tuple): A tuple of (width, height)\n            points_size (float): The marker size\n        Returns:\n            ax (matplotlib.axes.Axes): An Axes object with the PCA plot\n        \"\"\"\nembeddings_array = np.array(list(self.embeddings.values()))\nelement_array = np.array(self.element_list)\ntsne = TSNE(n_components)\ntsne_result = tsne.fit_transform(embeddings_array)\ntsne_df = pd.DataFrame(\n{\n\"tsne_dim1\": tsne_result[:, 0],\n\"tsne_dim2\": tsne_result[:, 1],\n\"element\": element_array,\n\"group\": list(self.element_groups_dict.values()),\n}\n)\n# Create the t-SNE plot\nfig, ax = plt.subplots(figsize=figsize)\nsns.scatterplot(\nx=\"tsne_dim1\",\ny=\"tsne_dim2\",\ndata=tsne_df,\nhue=points_hue,\ns=points_size,\nax=ax,\n)\n# lim = (tsne_result.min()-5, tsne_result.max()+5)\n# ax.set_xlim(lim)\n# ax.set_ylim(lim)\nplt.xlabel(\"Dimension 1\")\nplt.ylabel(\"Dimension 2\")\n# Label the points\nfor i in range(tsne_df.shape[0]):\nplt.text(\nx=tsne_df[\"tsne_dim1\"][i],\ny=tsne_df[\"tsne_dim2\"][i],\ns=tsne_df[\"element\"][i],\n)\nreturn plt\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.element_groups_dict","title":"<code>element_groups_dict: Dict[str, str]</code>  <code>property</code>","text":"<p>Return a dictionary of {element: element type} pairs.</p> <p>e.g. {'He':'Noble gas'}</p>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.element_list","title":"<code>element_list: list</code>  <code>property</code>","text":"<p>Return the elements of the embedding.</p>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.__init__","title":"<code>__init__(embeddings, embedding_name=None)</code>","text":"<p>Initialise the Embedding class.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>dict</code> <p>A {element_symbol: vector} dictionary</p> required <code>embedding_name</code> <code>str</code> <p>The name of the elemental representation</p> <code>None</code> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def __init__(self, embeddings: dict, embedding_name: Optional[str] = None):\n\"\"\"Initialise the Embedding class.\n    Args:\n        embeddings (dict): A {element_symbol: vector} dictionary\n        embedding_name (str): The name of the elemental representation\n    \"\"\"\nself.embeddings = embeddings\nself.embedding_name = embedding_name\n# Grab a random value from the embedding vector\n_rand_embed = random.choice(list(self.embeddings.values()))\n# Convert embeddings to numpy array if not already a numpy array\nif not isinstance(_rand_embed, np.ndarray):\nself.embeddings = {\nele: np.array(self.embeddings[ele]) for ele in self.embeddings\n}\n# Determines if the embedding vector has a length attribute\n# (i.e. is not a scalar int or float)\n# If the 'vector' is a scalar/float, the representation is linear (dim=1)\nif hasattr(_rand_embed, \"__len__\") and (not isinstance(_rand_embed, str)):\nself.dim: int = len(random.choice(list(self.embeddings.values())))\nelse:\nself.dim: int = int(1)\n# Dummy initialisation for results\nself._data = []\nself._pca_data = None  # type: Optional[np.ndarray]\nself._tsne_data = None  # type: Optional[np.ndarray]\nself._umap_data = None  # type: Optional[np.ndarray]\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.as_dataframe","title":"<code>as_dataframe(columns='components')</code>","text":"<p>Return the embedding as a pandas Dataframe.</p> <p>The first column is the elements and each other column represents a component of the embedding.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>A string to specify if the columns are the vector components</p> <code>'components'</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pandas.DataFrame</code> <p>A pandas dataframe object</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def as_dataframe(self, columns: str = \"components\") -&gt; pd.DataFrame:\n\"\"\"\n    Return the embedding as a pandas Dataframe.\n    The first column is the elements and each other\n    column represents a component of the embedding.\n    Args:\n        columns (str): A string to specify if the columns are the vector components\n        and the index is the elements (`columns='components')\n        or the columns are the elements (`columns='elements'`).\n    Returns:\n        df (pandas.DataFrame): A pandas dataframe object\n    \"\"\"\nembedding = self.embeddings\ndf = pd.DataFrame(embedding)\nif columns == \"components\":\nreturn df.T\nelif columns == \"elements\":\nreturn df\nelse:\nraise (\nValueError(\nf\"{columns} is not a valid keyword argument. \"\n\"Choose either 'components' or 'elements\"\n)\n)\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate","title":"<code>calculate(mode='all')</code>","text":"<p>Calculate the pairwise statistics of the elements present.</p> <p>The pairwise statistics include the distance and correlation metrics</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Specifies which pairwise statistics to calculate. <code>mode=\"all\"</code> will calculate all available distance and correlation metrics; <code>mode=\"correlation\"</code> will only calculate correlation metrics and <code>mode=\"distance\"</code> will only calculate distance metrics.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def calculate(self, mode: str = \"all\") -&gt; None:\n\"\"\"\n    Calculate the pairwise statistics of the elements present.\n    The pairwise statistics include the distance and correlation metrics\n    Args:\n        mode (str): Specifies which pairwise statistics to calculate. `mode=\"all\"`\n            will calculate all available distance and correlation metrics;\n            `mode=\"correlation\"` will only calculate correlation metrics\n            and `mode=\"distance\"` will only calculate distance metrics.\n    Returns:\n        None\n    \"\"\"\nele_pairs = self.create_pairs()\ntable = []\n# columns = [\"element_1\", \"element_2\", \"pearson_corr\", \"\"]\nfor ele1, ele2 in ele_pairs:\ntemp_dict = {\"element_1\": ele1, \"element_2\": ele2}\ntable.append(temp_dict)\npass\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_PC","title":"<code>calculate_PC(n_components=2, scale=True, **kwargs)</code>","text":"<p>Calculate the principal componenets (PC) of the embeddings.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def calculate_PC(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate the principal componenets (PC) of the embeddings.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\npca = decomposition.PCA(\nn_components=n_components, **kwargs\n)  # project to N dimensions\npca.fit(embeddings_array)\nself._pca_data = pca.transform(embeddings_array)\nreturn self._pca_data\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_UMAP","title":"<code>calculate_UMAP(n_components=2, scale=True, **kwargs)</code>","text":"<p>Calculate UMAP embeddings.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def calculate_UMAP(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate UMAP embeddings.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\numap = UMAP(n_components=n_components, **kwargs)\numap_result = umap.fit_transform(embeddings_array)\nself._umap_data = umap_result\nreturn self._umap_data\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.calculate_tSNE","title":"<code>calculate_tSNE(n_components=2, scale=True, **kwargs)</code>","text":"<p>Calculate t-SNE components.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def calculate_tSNE(self, n_components: int = 2, scale: bool = True, **kwargs):\n\"\"\"Calculate t-SNE components.\"\"\"\nif scale:\nembeddings_array = StandardScaler().fit_transform(\nnp.array(list(self.embeddings.values()))\n)\nelse:\nembeddings_array = np.array(list(self.embeddings.values()))\ntsne = TSNE(n_components=n_components, **kwargs)\ntsne_result = tsne.fit_transform(embeddings_array)\nself._tsne_data = tsne_result\nreturn self._tsne_data\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.citation","title":"<code>citation()</code>","text":"<p>Return a citation for the embedding.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def citation(self) -&gt; List[str]:\n\"\"\"Return a citation for the embedding.\"\"\"\nif self.embedding_name in [\"magpie\", \"magpie_sc\"]:\ncitation = [\n\"@article{ward2016general,\"\n\"title={A general-purpose machine learning framework for \"\n\"predicting properties of inorganic materials},\"\n\"author={Ward, Logan and Agrawal, Ankit and Choudhary, Alok \"\n\"and Wolverton, Christopher},\"\n\"journal={npj Computational Materials},\"\n\"volume={2},\"\n\"number={1},\"\n\"pages={1--7},\"\n\"year={2016},\"\n\"publisher={Nature Publishing Group}}\"\n]\nelif self.embedding_name == \"mat2vec\":\ncitation = [\n\"@article{tshitoyan2019unsupervised,\"\n\"title={Unsupervised word embeddings capture latent knowledge \"\n\"from materials science literature},\"\n\"author={Tshitoyan, Vahe and Dagdelen, John and Weston, Leigh \"\n\"and Dunn, Alexander and Rong, Ziqin and Kononova, Olga \"\n\"and Persson, Kristin A and Ceder, Gerbrand and Jain, Anubhav},\"\n\"journal={Nature},\"\n\"volume={571},\"\n\"number={7763},\"\n\"pages={95--98},\"\n\"year={2019},\"\n\"publisher={Nature Publishing Group} }\"\n]\nelif self.embedding_name == \"matscholar\":\ncitation = [\n\"@article{weston2019named,\"\n\"title={Named entity recognition and normalization applied to \"\n\"large-scale information extraction from the materials \"\n\"science literature},\"\n\"author={Weston, Leigh and Tshitoyan, Vahe and Dagdelen, John and \"\n\"Kononova, Olga and Trewartha, Amalie and Persson, Kristin A and \"\n\"Ceder, Gerbrand and Jain, Anubhav},\"\n\"journal={Journal of chemical information and modeling},\"\n\"volume={59},\"\n\"number={9},\"\n\"pages={3692--3702},\"\n\"year={2019},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name == \"megnet16\":\ncitation = [\n\"@article{chen2019graph,\"\n\"title={Graph networks as a universal machine learning framework \"\n\"for molecules and crystals},\"\n\"author={Chen, Chi and Ye, Weike and Zuo, Yunxing and \"\n\"Zheng, Chen and Ong, Shyue Ping},\"\n\"journal={Chemistry of Materials},\"\n\"volume={31},\"\n\"number={9},\"\n\"pages={3564--3572},\"\n\"year={2019},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name in [\"oliynyk\", \"oliynyk_sc\"]:\ncitation = [\n\"              @article{oliynyk2016high,\"\n\"title={High-throughput machine-learning-driven synthesis \"\n\"of full-Heusler compounds},\"\n\"author={Oliynyk, Anton O and Antono, Erin and Sparks, Taylor D and \"\n\"Ghadbeigi, Leila and Gaultois, Michael W and \"\n\"Meredig, Bryce and Mar, Arthur},\"\n\"journal={Chemistry of Materials},\"\n\"volume={28},\"\n\"number={20},\"\n\"pages={7324--7331},\"\n\"year={2016},\"\n\"publisher={ACS Publications} }\"\n]\nelif self.embedding_name == \"skipatom\":\ncitation = [\n\"@article{antunes2022distributed,\"\n\"title={Distributed representations of atoms and materials \"\n\"for machine learning},\"\n\"author={Antunes, Luis M and Grau-Crespo, Ricardo and Butler, Keith T},\"\n\"journal={npj Computational Materials},\"\n\"volume={8},\"\n\"number={1},\"\n\"pages={1--9},\"\n\"year={2022},\"\n\"publisher={Nature Publishing Group} }\"\n]\nelif self.embedding_name == \"mod_petti\":\ncitation = [\n\"@article{glawe2016optimal,\"\n\"title={The optimal one dimensional periodic table: \"\n\"a modified Pettifor chemical scale from data mining},\"\n\"author={Glawe, Henning and Sanna, Antonio and Gross, \"\n\"EKU and Marques, Miguel AL},\"\n\"journal={New Journal of Physics},\"\n\"volume={18},\"\n\"number={9},\"\n\"pages={093011},\"\n\"year={2016},\"\n\"publisher={IOP Publishing} }\"\n]\nelse:\ncitation = []\nreturn citation\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.compute_correlation_metric","title":"<code>compute_correlation_metric(ele1, ele2, metric='pearson')</code>","text":"<p>Compute the correlation/similarity metric between two vectors.</p> <p>Allowed metrics: * Pearson * Spearman * Cosine similarity</p> <p>Parameters:</p> Name Type Description Default <code>ele1</code> <code>str</code> <p>element symbol</p> required <code>ele2</code> <code>str</code> <p>element symbol</p> required <code>metric</code> <code>str</code> <p>name of a correlation metric.</p> <code>'pearson'</code> <p>Returns:</p> Type Description <code>Union[PearsonRResult, SpearmanrResult, float]</code> <p>PearsonResult | SpearmanrResult | float: correlation/similarity metric</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def compute_correlation_metric(\nself, ele1: str, ele2: str, metric: str = \"pearson\"\n) -&gt; Union[PearsonRResult, SpearmanrResult, float]:\n\"\"\"\n    Compute the correlation/similarity metric between two vectors.\n    Allowed metrics:\n    * Pearson\n    * Spearman\n    * Cosine similarity\n    Args:\n        ele1 (str): element symbol\n        ele2 (str): element symbol\n        metric (str): name of a correlation metric.\n        Options are \"spearman\", \"pearson\" and \"cosine_similarity\".\n    Returns:\n        PearsonResult | SpearmanrResult | float: correlation/similarity metric\n    \"\"\"\n# Define the allowable metrics\nscipy_corrs = {\"pearson\": pearsonr, \"spearman\": spearmanr}\nif metric in scipy_corrs:\nreturn scipy_corrs[metric](self.embeddings[ele1], self.embeddings[ele2])\nelif metric == \"cosine_similarity\":\nreturn cosine_similarity(self.embeddings[ele1], self.embeddings[ele2])\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.compute_distance_metric","title":"<code>compute_distance_metric(ele1, ele2, metric='euclidean')</code>","text":"<p>Compute distance metric between two vectors.</p> <p>Allowed metrics:</p> <ul> <li>euclidean</li> <li>manhattan</li> <li>chebyshev</li> <li>wasserstein</li> <li>energy</li> <li>cosine_distance</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ele1</code> <code>str</code> <p>element symbol</p> required <code>ele2</code> <code>str</code> <p>element symbol</p> required <code>metric</code> <code>str</code> <p>name of a distance metric</p> <code>'euclidean'</code> <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>distance between embedding vectors</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def compute_distance_metric(\nself, ele1: str, ele2: str, metric: str = \"euclidean\"\n) -&gt; float:\n\"\"\"\n    Compute distance metric between two vectors.\n    Allowed metrics:\n    * euclidean\n    * manhattan\n    * chebyshev\n    * wasserstein\n    * energy\n    * cosine_distance\n    Args:\n        ele1 (str): element symbol\n        ele2 (str): element symbol\n        metric (str): name of a distance metric\n    Returns:\n        distance (float): distance between embedding vectors\n    \"\"\"\n# Define the allowable metrics\nscikit_metrics = [\"euclidean\", \"manhattan\", \"chebyshev\"]\nscipy_metrics = {\"wasserstein\": wasserstein_distance, \"energy\": energy_distance}\nvalid_metrics = scikit_metrics + list(scipy_metrics.keys()) + [\"cosine\"]\n# Validate if the elements are within the embedding vector\nif not all([self._is_el_in_embedding(ele1), self._is_el_in_embedding(ele2)]):\nif not self._is_el_in_embedding(ele1):\nprint(f\"{ele1} is not an element included within the atomic embeddings\")\nraise ValueError\nelif not self._is_el_in_embedding(ele2):\nprint(f\"{ele2} is not an element included within the atomic embeddings\")\nraise ValueError\n# Compute the distance measure\nif metric in scikit_metrics:\ndistance = DistanceMetric.get_metric(metric)\nreturn distance.pairwise(\nself.embeddings[ele1].reshape(1, -1),\nself.embeddings[ele2].reshape(1, -1),\n)[0][0]\nelif metric in scipy_metrics.keys():\nreturn scipy_metrics[metric](self.embeddings[ele1], self.embeddings[ele2])\nelif metric == \"cosine_distance\":\nreturn cosine_distance(self.embeddings[ele1], self.embeddings[ele2])\nelse:\nprint(\n\"Invalid distance metric.\"\nf\"Use one of the following metrics:{valid_metrics}\"\n)\nraise ValueError\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.correlation_df","title":"<code>correlation_df(metric='pearson')</code>","text":"<p>Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].</p> <p>Allowed metrics:</p> <ul> <li>pearson</li> <li>spearman</li> <li>cosine_similarity</li> </ul> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>A distance metric.</p> <code>'pearson'</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pandas.DataFrame</code> <p>A dataframe with columns [\"ele_1\", \"ele_2\", metric].</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def correlation_df(self, metric: str = \"pearson\") -&gt; pd.DataFrame:\n\"\"\"\n    Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].\n    Allowed metrics:\n    * pearson\n    * spearman\n    * cosine_similarity\n    Args:\n        metric (str): A distance metric.\n    Returns:\n        df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric].\n    \"\"\"\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\ndist = self.compute_correlation_metric(ele1, ele2, metric=metric)\nif metric in [\"pearson\", \"spearman\"]:\ndist = dist[0]\ntable.append((ele1, ele2, dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, dist))\ncorr_df = pd.DataFrame(table, columns=[\"ele_1\", \"ele_2\", metric])\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\nZ_1 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_1\"]]\nZ_2 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df[\"Z_1\"] = Z_1\ncorr_df[\"Z_2\"] = Z_2\ncorr_df = corr_df[[\"ele_1\", \"ele_2\", \"mend_1\", \"mend_2\", \"Z_1\", \"Z_2\", metric]]\nreturn corr_df\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.correlation_pivot_table","title":"<code>correlation_pivot_table(metric='pearson', sortby='mendeleev')</code>","text":"<p>Return a pandas.DataFrame style pivot.</p> <p>The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>A distance metric.</p> <code>'pearson'</code> <code>sortby</code> <code>str</code> <p>Sort the pivot table by either \"mendeleev\" or \"atomic_number\".</p> <code>'mendeleev'</code> <p>Returns:</p> Name Type Description <code>distance_pivot</code> <code>pandas.DataFrame</code> <p>A pandas DataFrame pivot table.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def correlation_pivot_table(\nself, metric: str = \"pearson\", sortby: str = \"mendeleev\"\n) -&gt; pd.DataFrame:\n\"\"\"\n    Return a pandas.DataFrame style pivot.\n    The index and column being either the mendeleev number or atomic number\n    of the element pairs and the values being a user-specified distance metric.\n    Args:\n        metric (str): A distance metric.\n        sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\".\n    Returns:\n        distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table.\n    \"\"\"\ncorr_df = self.correlation_df(metric=metric)\nif sortby == \"mendeleev\":\ncorrelation_pivot = corr_df.pivot_table(\nvalues=metric, index=\"mend_1\", columns=\"mend_2\"\n)\nreturn correlation_pivot\nelif sortby == \"atomic_number\":\ncorrelation_pivot = corr_df.pivot_table(\nvalues=metric, index=\"Z_1\", columns=\"Z_2\"\n)\nreturn correlation_pivot\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.create_pairs","title":"<code>create_pairs()</code>","text":"<p>Create all possible pairs of elements.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def create_pairs(self):\n\"\"\"Create all possible pairs of elements.\"\"\"\nele_list = self.element_list\nele_pairs = combinations_with_replacement(ele_list, 2)\nreturn ele_pairs\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.distance_df","title":"<code>distance_df(metric='euclidean')</code>","text":"<p>Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].</p> <p>Allowed metrics:</p> <ul> <li>euclidean</li> <li>manhattan</li> <li>chebyshev</li> <li>wasserstein</li> <li>energy</li> </ul> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>A distance metric.</p> <code>'euclidean'</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pandas.DataFrame</code> <p>A dataframe with columns [\"ele_1\", \"ele_2\", metric].</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def distance_df(self, metric: str = \"euclidean\") -&gt; pd.DataFrame:\n\"\"\"\n    Return a dataframe with columns [\"ele_1\", \"ele_2\", metric].\n    Allowed metrics:\n    * euclidean\n    * manhattan\n    * chebyshev\n    * wasserstein\n    * energy\n    Args:\n        metric (str): A distance metric.\n    Returns:\n        df (pandas.DataFrame): A dataframe with columns [\"ele_1\", \"ele_2\", metric].\n    \"\"\"\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\ndist = self.compute_distance_metric(ele1, ele2, metric=metric)\ntable.append((ele1, ele2, dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, dist))\ncorr_df = pd.DataFrame(table, columns=[\"ele_1\", \"ele_2\", metric])\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\nZ_1 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_1\"]]\nZ_2 = [(pt[ele][\"number\"], ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df[\"Z_1\"] = Z_1\ncorr_df[\"Z_2\"] = Z_2\ncorr_df = corr_df[[\"ele_1\", \"ele_2\", \"mend_1\", \"mend_2\", \"Z_1\", \"Z_2\", metric]]\nreturn corr_df\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.distance_pivot_table","title":"<code>distance_pivot_table(metric='euclidean', sortby='mendeleev')</code>","text":"<p>Return a pandas.DataFrame style pivot.</p> <p>The index and column being either the mendeleev number or atomic number of the element pairs and the values being a user-specified distance metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>A distance metric.</p> <code>'euclidean'</code> <code>sortby</code> <code>str</code> <p>Sort the pivot table by either \"mendeleev\" or \"atomic_number\".</p> <code>'mendeleev'</code> <p>Returns:</p> Name Type Description <code>distance_pivot</code> <code>pandas.DataFrame</code> <p>A pandas DataFrame pivot table.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def distance_pivot_table(\nself, metric: str = \"euclidean\", sortby: str = \"mendeleev\"\n) -&gt; pd.DataFrame:\n\"\"\"\n    Return a pandas.DataFrame style pivot.\n    The index and column being either the mendeleev number or atomic number\n    of the element pairs and the values being a user-specified distance metric.\n    Args:\n        metric (str): A distance metric.\n        sortby (str): Sort the pivot table by either \"mendeleev\" or \"atomic_number\".\n    Returns:\n        distance_pivot (pandas.DataFrame): A pandas DataFrame pivot table.\n    \"\"\"\ncorr_df = self.distance_df(metric=metric)\nif sortby == \"mendeleev\":\ndistance_pivot = corr_df.pivot_table(\nvalues=metric, index=\"mend_1\", columns=\"mend_2\"\n)\nreturn distance_pivot\nelif sortby == \"atomic_number\":\ndistance_pivot = corr_df.pivot_table(\nvalues=metric, index=\"Z_1\", columns=\"Z_2\"\n)\nreturn distance_pivot\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.from_csv","title":"<code>from_csv(embedding_csv)</code>  <code>staticmethod</code>","text":"<p>Create an instance of the Embedding class from a csv file.</p> <p>The first column of the csv file must contain the elements and be named element.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_csv</code> <code>str</code> <p>Filepath of the csv file</p> required Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>@staticmethod\ndef from_csv(embedding_csv):\n\"\"\"\n    Create an instance of the Embedding class from a csv file.\n    The first column of the csv file must contain the elements and be named element.\n    Args:\n        embedding_csv (str): Filepath of the csv file\n    \"\"\"\n# Need to add validation handling for csv files\ndf = pd.read_csv(embedding_csv)\nelements = list(df[\"element\"])\ndf.drop([\"element\"], axis=1, inplace=True)\nembeds_array = df.to_numpy()\nembedding_data = {\nelements[i]: embeds_array[i] for i in range(len(embeds_array))\n}\nreturn Embedding(embedding_data)\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.from_json","title":"<code>from_json(embedding_json)</code>  <code>staticmethod</code>","text":"<p>Create an instance of the Embedding class from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_json</code> <code>str</code> <p>Filepath of the json file</p> required Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>@staticmethod\ndef from_json(embedding_json):\n\"\"\"\n    Create an instance of the Embedding class from a json file.\n    Args:\n        embedding_json (str): Filepath of the json file\n    \"\"\"\n# Need to add validation handling for JSONs in different formats\nwith open(embedding_json) as f:\nembedding_data = json.load(f)\nreturn Embedding(embedding_data)\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.load_data","title":"<code>load_data(embedding_name=None)</code>  <code>staticmethod</code>","text":"<p>Create an instance of the <code>Embedding</code> class from a default embedding file.</p> <p>The default embeddings are in the table below:</p> Name str_name Magpie magpie Magpie (scaled) magpie_sc Mat2Vec mat2vec Matscholar matscholar Megnet (16 dimensions) megnet16 Modified pettifor scale mod_petti Oliynyk oliynyk Oliynyk (scaled) oliynyk_sc Random (200 dimensions) random_200 SkipAtom skipatom <p>Parameters:</p> Name Type Description Default <code>embedding_name</code> <code>str</code> <p>The str_name of an embedding file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Embedding</code> <p>class:<code>Embedding</code> instance.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>@staticmethod\ndef load_data(embedding_name: Optional[str] = None):\n\"\"\"\n    Create an instance of the `Embedding` class from a default embedding file.\n    The default embeddings are in the table below:\n    | **Name**                | **str_name** |\n    |-------------------------|--------------|\n    | Magpie                  | magpie       |\n    | Magpie (scaled)         | magpie_sc    |\n    | Mat2Vec                 | mat2vec      |\n    | Matscholar              | matscholar   |\n    | Megnet (16 dimensions)  | megnet16     |\n    | Modified pettifor scale | mod_petti    |\n    | Oliynyk                 | oliynyk      |\n    | Oliynyk (scaled)        | oliynyk_sc   |\n    | Random (200 dimensions) | random_200   |\n    | SkipAtom                | skipatom     |\n    Args:\n        embedding_name (str): The str_name of an embedding file.\n    Returns:\n        Embedding :class:`Embedding` instance.\n    \"\"\"\n_cbfv_files = {\n\"magpie\": \"magpie.csv\",\n\"magpie_sc\": \"magpie_sc.json\",\n\"mat2vec\": \"mat2vec.csv\",\n\"matscholar\": \"matscholar-embedding.json\",\n\"megnet16\": \"megnet16.json\",\n\"mod_petti\": \"mod_petti.json\",\n\"oliynyk\": \"oliynyk.json\",\n\"oliynyk_sc\": \"oliynyk_sc.json\",\n\"random_200\": \"random_200_new.csv\",\n\"skipatom\": \"skipatom_20201009_induced.csv\",\n}\n_cbfv_names = list(_cbfv_files.keys())\n_cbfv_names_others = [\ni\nfor i in _cbfv_names\nif i not in [\"skipatom\", \"random_200\", \"megnet16\", \"magpie\", \"mat2vec\"]\n]\n# Get the embeddings\nif embedding_name in _cbfv_files:\nif embedding_name in [\"skipatom\", \"random_200\", \"magpie\", \"mat2vec\"]:\n_csv = path.join(data_directory, _cbfv_files[embedding_name])\ndf = pd.read_csv(_csv)\n# Convert df to a dictionary of (ele:embeddings) pairs\nelements = list(df[\"element\"])\ndf.drop([\"element\"], axis=1, inplace=True)\nembeds_array = df.to_numpy()\nembedding_data = {\nelements[i]: embeds_array[i] for i in range(len(embeds_array))\n}\nelif embedding_name == \"megnet16\":\nmegnet16_json = path.join(data_directory, _cbfv_files[\"megnet16\"])\nwith open(megnet16_json) as f:\nembedding_data = json.load(f)\n# Remove 'Null' key from megnet embedding\ndel embedding_data[\"Null\"]\nelif embedding_name in _cbfv_names_others:\n_json = path.join(data_directory, _cbfv_files[embedding_name])\nwith open(_json) as f:\nembedding_data = json.load(f)\n# Load a json file from a file specified in the input\nelse:\nwith open(embedding_name) as f:\nembedding_data = json.load(f)\nelse:\nraise (\nValueError(\nf\"{embedding_name} not in the data directory or not in directory.\"\n)\n)\nreturn Embedding(embedding_data, embedding_name)\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.pearson_pivot_table","title":"<code>pearson_pivot_table()</code>","text":"<p>Return a pandas.DataFrame style pivot object.</p> <p>The index and column are the mendeleev number of the element pairs and the values being the pearson correlation metrics.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def pearson_pivot_table(self) -&gt; pd.DataFrame:\n\"\"\"\n    Return a pandas.DataFrame style pivot object.\n    The index and column are the mendeleev number of the element pairs\n    and the values being the pearson correlation metrics.\n    \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\ncorr_df = self.correlation_df()\npearson_pivot = corr_df.pivot_table(\nvalues=\"pearson_corr\", index=\"mend_1\", columns=\"mend_2\"\n)\nreturn pearson_pivot\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_PCA_2D","title":"<code>plot_PCA_2D(figsize=(16, 12), points_hue='group', points_size=200, **kwargs)</code>","text":"<p>Plot a PCA plot of the atomic embedding.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple</code> <p>A tuple of (width, height)</p> <code>(16, 12)</code> <code>points_size</code> <code>float</code> <p>The marker size</p> <code>200</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>An Axes object with the PCA plot</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def plot_PCA_2D(\nself,\nfigsize: Tuple[int, int] = (16, 12),\npoints_hue: str = \"group\",\npoints_size: int = 200,\n**kwargs,\n):\n\"\"\"Plot a PCA plot of the atomic embedding.\n    Args:\n        figsize (tuple): A tuple of (width, height)\n        points_size (float): The marker size\n    Returns:\n        ax (matplotlib.axes.Axes): An Axes object with the PCA plot\n    \"\"\"\nembeddings_array = np.array(list(self.embeddings.values()))\nelement_array = np.array(self.element_list)\npca = decomposition.PCA(n_components=2)  # project to 2 dimensions\npca.fit(embeddings_array)\nX = pca.transform(embeddings_array)\npca_dim1 = X[:, 0]\npca_dim2 = X[:, 1]\n# Create a dataframe to store the dimensions, labels and group info for the PCA\npca_df = pd.DataFrame(\n{\n\"pca_dim1\": pca_dim1,\n\"pca_dim2\": pca_dim2,\n\"element\": element_array,\n\"group\": list(self.element_groups_dict.values()),\n}\n)\nfig, ax = plt.subplots(figsize=figsize)\nsns.scatterplot(\nx=\"pca_dim1\",\ny=\"pca_dim2\",\ndata=pca_df,\nhue=points_hue,\ns=points_size,\n**kwargs,\nax=ax,\n)\nplt.xlabel(\"Dimension 1\")\nplt.ylabel(\"Dimension 2\")\nfor i in range(len(X)):\nplt.text(x=pca_dim1[i], y=pca_dim2[i], s=element_array[i])\nreturn plt\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_distance_correlation","title":"<code>plot_distance_correlation(metric='euclidean', figsize=(24, 24), **kwargs)</code>","text":"<p>Plot the heatmap of the pairwise distance metrics.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>A valid distance metric</p> <code>'euclidean'</code> <code>figsize</code> <code>tuple</code> <p>A tuple of (width, height)</p> <code>(24, 24)</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>An Axes object with the heatmap</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def plot_distance_correlation(\nself, metric: str = \"euclidean\", figsize: Tuple[int, int] = (24, 24), **kwargs\n):\n\"\"\"\n    Plot the heatmap of the pairwise distance metrics.\n    Args:\n        metric (str): A valid distance metric\n        figsize (tuple): A tuple of (width, height)\n    Returns:\n        ax (matplotlib.axes.Axes): An Axes object with the heatmap\n    \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\ndistance_pivot = self.distance_pivot_table(metric=metric)\nplt.figure(figsize=figsize)\nax = sns.heatmap(\ndistance_pivot, cmap=\"bwr\", square=True, linecolor=\"k\", **kwargs\n)\nreturn ax\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_pearson_correlation","title":"<code>plot_pearson_correlation(figsize=(24, 24), **kwargs)</code>","text":"<p>Plot the heatmap of the pearson correlation values.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple</code> <p>A tuple of (width, height).</p> <code>(24, 24)</code> <code>**kwargs</code> <p>Other keyword arguments to be passed to sns.heatmap</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib Axes</code> <p>An Axes object with the heatmap</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def plot_pearson_correlation(self, figsize: Tuple[int, int] = (24, 24), **kwargs):\n\"\"\"\n    Plot the heatmap of the pearson correlation values.\n    Args:\n        figsize (tuple): A tuple of (width, height).\n        **kwargs: Other keyword arguments to be passed to sns.heatmap\n    Returns:\n        ax (matplotlib Axes): An Axes object with the heatmap\n    \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\npearson_pivot = self.pearson_pivot_table()\nplt.figure(figsize=figsize)\nax = sns.heatmap(\npearson_pivot, cmap=\"bwr\", square=True, linecolor=\"k\", **kwargs\n)\nreturn ax\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.plot_tSNE","title":"<code>plot_tSNE(n_components=2, figsize=(16, 12), points_hue='group', points_size=200, **kwargs)</code>","text":"<p>Plot a t-SNE plot of the atomic embedding.</p> <p>Parameters:</p> Name Type Description Default <code>n_components</code> <code>int</code> <p>Number of t-SNE components to plot.</p> <code>2</code> <code>figsize</code> <code>tuple</code> <p>A tuple of (width, height)</p> <code>(16, 12)</code> <code>points_size</code> <code>float</code> <p>The marker size</p> <code>200</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>An Axes object with the PCA plot</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def plot_tSNE(\nself,\nn_components: str = 2,\nfigsize: Tuple[int, int] = (16, 12),\npoints_hue: str = \"group\",\npoints_size: int = 200,\n**kwargs,\n):\n\"\"\"Plot a t-SNE plot of the atomic embedding.\n    Args:\n        n_components (int): Number of t-SNE components to plot.\n        figsize (tuple): A tuple of (width, height)\n        points_size (float): The marker size\n    Returns:\n        ax (matplotlib.axes.Axes): An Axes object with the PCA plot\n    \"\"\"\nembeddings_array = np.array(list(self.embeddings.values()))\nelement_array = np.array(self.element_list)\ntsne = TSNE(n_components)\ntsne_result = tsne.fit_transform(embeddings_array)\ntsne_df = pd.DataFrame(\n{\n\"tsne_dim1\": tsne_result[:, 0],\n\"tsne_dim2\": tsne_result[:, 1],\n\"element\": element_array,\n\"group\": list(self.element_groups_dict.values()),\n}\n)\n# Create the t-SNE plot\nfig, ax = plt.subplots(figsize=figsize)\nsns.scatterplot(\nx=\"tsne_dim1\",\ny=\"tsne_dim2\",\ndata=tsne_df,\nhue=points_hue,\ns=points_size,\nax=ax,\n)\n# lim = (tsne_result.min()-5, tsne_result.max()+5)\n# ax.set_xlim(lim)\n# ax.set_ylim(lim)\nplt.xlabel(\"Dimension 1\")\nplt.ylabel(\"Dimension 2\")\n# Label the points\nfor i in range(tsne_df.shape[0]):\nplt.text(\nx=tsne_df[\"tsne_dim1\"][i],\ny=tsne_df[\"tsne_dim2\"][i],\ns=tsne_df[\"element\"][i],\n)\nreturn plt\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.remove_elements","title":"<code>remove_elements(elements, inplace=False)</code>","text":"<p>Remove elements from the Embedding instance.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>str,list(str</code> <p>An element symbol or a list of element symbols</p> required <code>inplace</code> <code>bool</code> <p>If True, elements are removed from the Embedding instance.</p> <code>False</code> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def remove_elements(self, elements: Union[str, List[str]], inplace: bool = False):\n# TO-DO allow removal by atomic numbers\n\"\"\"\n    Remove elements from the Embedding instance.\n    Args:\n        elements (str,list(str)): An element symbol or a list of element symbols\n        inplace (bool): If True, elements are removed from the Embedding instance.\n        If false, the original embedding instance is unchanged\n        and a new embedding instance with the elements removed is created.\n    \"\"\"\nif inplace:\nif isinstance(elements, str):\ndel self.embeddings[elements]\nelif isinstance(elements, list):\nfor el in elements:\ndel self.embeddings[el]\nreturn None\nelse:\nembeddings_copy = self.embeddings.copy()\nif isinstance(elements, str):\ndel embeddings_copy[elements]\nelif isinstance(elements, list):\nfor el in elements:\ndel embeddings_copy[el]\nreturn Embedding(embeddings_copy, self.embedding_name)\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.stats_correlation_df","title":"<code>stats_correlation_df()</code>","text":"<p>Return a pandas.DataFrame with correlation metrics.</p> <p>The columns of returned dataframe are: [element_1, element_2, pearson_corr, euclid_dist].</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def stats_correlation_df(self) -&gt; pd.DataFrame:\n\"\"\"Return a pandas.DataFrame with correlation metrics.\n     The columns of returned dataframe are:\n    [element_1, element_2, pearson_corr, euclid_dist].\n    \"\"\"\nwarnings.warn(\n\"This method is deprecated and will be removed in a future release. \",\nDeprecationWarning,\n)\nele_pairs = self.create_pairs()\ntable = []\nfor ele1, ele2 in ele_pairs:\npearson = pearsonr(self.embeddings[ele1], self.embeddings[ele2])\ndist = norm(self.embeddings[ele1] - self.embeddings[ele2])\ntable.append((ele1, ele2, pearson[0], dist))\nif ele1 != ele2:\ntable.append((ele2, ele1, pearson[0], dist))\ncorr_df = pd.DataFrame(\ntable,\ncolumns=[\n\"ele_1\",\n\"ele_2\",\n\"pearson_corr\",\n\"euclid_dist\",\n],\n)\nmend_1 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_1\"]]\nmend_2 = [(Element(ele).mendeleev_no, ele) for ele in corr_df[\"ele_2\"]]\ncorr_df[\"mend_1\"] = mend_1\ncorr_df[\"mend_2\"] = mend_2\ncorr_df = corr_df[\n[\n\"ele_1\",\n\"ele_2\",\n\"mend_1\",\n\"mend_2\",\n\"euclid_dist\",\n\"pearson_corr\",\n]\n]\nreturn corr_df\n</code></pre>"},{"location":"python_api/core/#AtomicEmbeddings.core.Embedding.to","title":"<code>to(fmt='', filename='')</code>","text":"<p>Output the embedding to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>The file format to output the embedding to.</p> <code>''</code> <code>filename</code> <code>str</code> <p>The name of the file to be outputted</p> <code>''</code> <p>Returns:</p> Type Description <p>(str) if filename not specified, otherwise None.</p> Source code in <code>AtomicEmbeddings/core.py</code> <pre><code>def to(self, fmt: str = \"\", filename: Optional[str] = \"\"):\n\"\"\"\n    Output the embedding to a file.\n    Args:\n        fmt (str): The file format to output the embedding to.\n        Options include \"json\" and \"csv\".\n        filename (str): The name of the file to be outputted\n    Returns:\n        (str) if filename not specified, otherwise None.\n    \"\"\"\nfmt = fmt.lower()\nif fmt == \"json\" or fnmatch.fnmatch(filename, \"*.json\"):\nj = json.dumps(self.embeddings, cls=NumpyEncoder)\nif filename:\nif not filename.endswith(\".json\"):\nfilename = filename + \".json\"\nwith open(filename, \"w\") as file:\nfile.write(j)\nelse:\nreturn j\nelif fmt == \"csv\" or fnmatch.fnmatch(filename, \"*.csv\"):\nif filename:\nif not filename.endswith(\".csv\"):\nfilename = filename + \".csv\"\nself.as_dataframe().to_csv(filename, index_label=\"element\")\nelse:\nreturn self.as_dataframe().to_csv(index_label=\"element\")\nelse:\nraise ValueError(f\"{str(fmt)} is an invalid file format\")\n</code></pre>"},{"location":"python_api/plotter/","title":"Plotter module","text":"<p>Provides the plotting functions for visualising Embeddings.</p>"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.dimension_plotter","title":"<code>dimension_plotter(embedding, ax=None, n_components=2, reducer='umap', adjusttext=True, **kwargs)</code>","text":"<p>Plot the reduced dimensions of the embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>embedding</code> <code>Embedding</code> <p>The embedding to be plotted.</p> required <code>ax</code> <code>plt.axes</code> <p>The axes to plot on, by default None</p> <code>None</code> <code>n_components</code> <code>int</code> <p>The number of components to reduce to, by default 2</p> <code>2</code> <code>reducer</code> <code>str</code> <p>The dimensionality reduction algorithm to use, by default \"umap\"</p> <code>'umap'</code> <code>adjust_text</code> <code>bool</code> <p>Whether to avoid overlap of the text labels, by default True</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the dimensionality reduction algorithm.</p> <code>{}</code> Source code in <code>AtomicEmbeddings/plotter.py</code> <pre><code>def dimension_plotter(\nembedding: Embedding,\nax: Optional[plt.axes] = None,\nn_components: int = 2,\nreducer: str = \"umap\",\nadjusttext: bool = True,\n**kwargs,\n):\n\"\"\"Plot the reduced dimensions of the embeddings.\n    Args:\n        embedding (Embedding): The embedding to be plotted.\n        ax (plt.axes, optional): The axes to plot on, by default None\n        n_components (int): The number of components to reduce to, by default 2\n        reducer (str): The dimensionality reduction algorithm to use, by default \"umap\"\n        adjust_text (bool): Whether to avoid overlap of the text labels, by default True\n        **kwargs:  Additional keyword arguments to pass to the\n          dimensionality reduction algorithm.\n    \"\"\"\nif reducer == \"umap\":\nif (\nembedding._umap_data is not None\nand embedding._umap_data.shape[1] == n_components\n):\nreduced = embedding._umap_data\nelse:\nreduced = embedding.calculate_UMAP(n_components=n_components, **kwargs)\nelif reducer == \"tsne\":\nif (\nembedding._tsne_data is not None\nand embedding._tsne_data.shape[1] == n_components\n):\nreduced = embedding._tsne_data\nelse:\nreduced = embedding.calculate_tSNE(n_components=n_components, **kwargs)\nelif reducer == \"pca\":\nif (\nembedding._pca_data is not None\nand embedding._pca_data.shape[1] == n_components\n):\nreduced = embedding._pca_data\nelse:\nreduced = embedding.calculate_PC(n_components=n_components, **kwargs)\nelse:\nraise ValueError(\"Unrecognised reducer.\")\nif reduced.shape[1] == 2:\ndf = pd.DataFrame(\n{\n\"x\": reduced[:, 0],\n\"y\": reduced[:, 1],\n\"element\": np.array(embedding.element_list),\n\"Group\": list(embedding.element_groups_dict.values()),\n}\n)\nif not ax:\nfig, ax = plt.subplots()\nsns.scatterplot(data=df, x=\"x\", y=\"y\", hue=\"Group\", ax=ax, **kwargs)\nax.set_xlabel(\"Dimension 1\")\nax.set_ylabel(\"Dimension 2\")\ntexts = [\nax.text(df[\"x\"][i], df[\"y\"][i], df[\"element\"][i], fontsize=12)\nfor i in range(len(df))\n]\nif adjusttext:\nadjust_text(\ntexts, arrowprops=dict(arrowstyle=\"-\", color=\"gray\", lw=0.5), ax=ax\n)\nelif reduced.shape[1] == 3:\ndf = pd.DataFrame(\n{\n\"x\": reduced[:, 0],\n\"y\": reduced[:, 1],\n\"z\": reduced[:, 2],\n\"element\": np.array(embedding.element_list),\n\"group\": list(embedding.element_groups_dict.values()),\n}\n)\nif not ax:\nfig = plt.figure()  # noqa: F841\nax = plt.axes(projection=\"3d\")\nax.scatter3D(\ndf[\"x\"],\ndf[\"y\"],\ndf[\"z\"],\n)\nax.set_xlabel(\"Dimension 1\")\nax.set_ylabel(\"Dimension 2\")\nax.set_zlabel(\"Dimension 3\")\nfor i in range(len(df)):\nax.text(df[\"x\"][i], df[\"y\"][i], df[\"z\"][i], df[\"element\"][i], fontsize=12)\nelse:\nraise ValueError(\"Unrecognised number of dimensions.\")\nax.set_title(embedding.embedding_name, fontdict={\"fontweight\": \"bold\"})\nreturn ax\n</code></pre>"},{"location":"python_api/plotter/#AtomicEmbeddings.plotter.heatmap_plotter","title":"<code>heatmap_plotter(embedding, metric, cmap='Blues', sortaxisby='mendeleev', ax=None, show_axislabels=True, **kwargs)</code>","text":"<p>Plot multiple heatmaps of the embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>embedding</code> <code>Embedding</code> <p>The embeddings to be plotted.</p> required <code>metric</code> <code>str</code> <p>The distance metric / similarity measure to be plotted.</p> required <code>cmap</code> <code>str</code> <p>The colourmap for the heatmap.</p> <code>'Blues'</code> <code>sortaxisby</code> <code>str</code> <p>The attribute to sort the axis by,</p> <code>'mendeleev'</code> <code>ax</code> <code>plt.axes</code> <p>The axes to plot on, by default None</p> <code>None</code> <code>show_axislabels</code> <code>bool</code> <p>Whether to show the axis, by default True</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to seaborn.heatmap</p> <code>{}</code> Source code in <code>AtomicEmbeddings/plotter.py</code> <pre><code>def heatmap_plotter(\nembedding: Embedding,\nmetric: str,\ncmap: str = \"Blues\",\nsortaxisby: str = \"mendeleev\",\nax: Optional[plt.axes] = None,\nshow_axislabels: bool = True,\n**kwargs,\n):\n\"\"\"\n    Plot multiple heatmaps of the embeddings.\n    Args:\n        embedding (Embedding): The embeddings to be plotted.\n        metric (str): The distance metric / similarity measure to be plotted.\n        cmap (str): The colourmap for the heatmap.\n        sortaxisby (str, optional): The attribute to sort the axis by,\n        by default \"mendeleev_number\".\n        Options are \"mendeleev_number\", \"atomic_number\"\n        ax (plt.axes, optional): The axes to plot on, by default None\n        show_axislabels (bool, optional): Whether to show the axis, by default True\n        **kwargs: Additional keyword arguments to pass to seaborn.heatmap\n    \"\"\"\nif not ax:\nfig, ax = plt.subplots()\ncorrelation_metrics = [\"spearman\", \"pearson\", \"cosine_similarity\"]\ndistance_metrics = [\n\"euclidean\",\n\"manhattan\",\n\"cosine_distance\",\n\"chebyshev\",\n\"wasserstein\",\n\"energy\",\n]\nif metric in correlation_metrics:\np = embedding.correlation_pivot_table(metric=metric, sortby=sortaxisby)\nelif metric in distance_metrics:\np = embedding.distance_pivot_table(metric=metric, sortby=sortaxisby)\nxlabels = [i[1] for i in p.index]\nylabels = [i[1] for i in p.columns]\nsns.heatmap(\np,\ncmap=cmap,\nsquare=\"True\",\nlinecolor=\"k\",\nax=ax,\ncbar_kws={\n\"shrink\": 0.5,\n},\nxticklabels=True,\nyticklabels=True,\n**kwargs,\n)\nax.set_title(\nembedding.embedding_name,\nfontdict={\n# \"fontsize\": 30,\n\"fontweight\": \"bold\"\n},\n)\nif not show_axislabels:\nax.set_xticklabels([])\nax.set_yticklabels([])\nax.set_xticks([])\nax.set_yticks([])\nelse:\nax.set_xticklabels(\nxlabels,\n)\nax.set_yticklabels(ylabels)\nax.set_xlabel(\"\")\nax.set_ylabel(\"\")\nreturn ax\n</code></pre>"},{"location":"python_api/python_api/","title":"Atomic Embeddings Python package","text":"<p>The core module of the <code>AtomicEmbeddings</code> contains the <code>Embedding</code> class which is used to store and manipulate elemental representation data. This part of the project documentation provides the python API for the <code>AtomicEmbeddings</code> package.</p> <p>Core module</p> <p>Composition module</p> <p>Plotter module</p>"}]}